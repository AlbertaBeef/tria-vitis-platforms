From ecc7394cfe2701db2ecc999b356ee56fdae61af3 Mon Sep 17 00:00:00 2001
From: verma <amit.verma@amd.com>
Date: Mon, 31 Jul 2023 16:59:30 +0530
Subject: [PATCH 4/4] media: i2c: i2c client driver for ox03f10 sensor and
 MAX9295 serialzier

The i2c driver supports cofiguration of multiple instance of image
sensor and serializer to capture data from image sensor, serialize it
and pass it to deserializer.

Signed-off-by: verma <amit.verma@amd.com>
---
 drivers/media/i2c/ox03f10.c        | 1367 +++++++++++++++++++++++++++
 drivers/media/i2c/ox03f10_tables.h | 1776 ++++++++++++++++++++++++++++++++++++
 2 files changed, 3143 insertions(+)
 create mode 100644 drivers/media/i2c/ox03f10.c
 create mode 100644 drivers/media/i2c/ox03f10_tables.h

diff --git a/drivers/media/i2c/ox03f10.c b/drivers/media/i2c/ox03f10.c
new file mode 100644
index 0000000..057bc55
--- /dev/null
+++ b/drivers/media/i2c/ox03f10.c
@@ -0,0 +1,1367 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ox03f10.c - OX03F10 CMOS Image Sensor driver -Serializer Driver
+ *
+ * Copyright (C) 2022, Leopard Imaging, Inc.
+ *
+ * Weicen Zhou <weicenz@leopardimaging.com>
+ * Amit Verma <amit.verma@amd.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/videodev2.h>
+#include <linux/device.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <linux/err.h>
+
+#include "ox03f10_tables.h"
+
+#define MAX9295_DEFAULT_ADDR	0x62	/* 8bit */
+#define SENSOR_DEFAULT_ADDRESS	0x36
+#define OX03F10_VTS_H		(0x380E)
+#define OX03F10_VTS_L		(0x380F)
+
+static const struct regmap_config serializer_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE,
+};
+
+/* regulator supplies */
+static const char *const ox03f10_supply_names[] = {
+	"vddl",  /* IF (1.2V) supply */
+	"vdig",  /* Digital Core (1.8V) supply */
+	"vana",  /* Analog (2.8V) supply */
+};
+
+#define OX03F10_NUM_SUPPLIES ARRAY_SIZE(ox03f10_supply_names)
+
+static const struct regmap_config ox03f10_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE,
+};
+
+/*
+ * Parameters for each ox03f10 readout mode.
+ *
+ * These are the values to configure the sensor in one of the
+ * implemented modes.
+ *
+ * @init_regs: registers to initialize the mode
+ * @wbin_ratio: width downscale factor (e.g. 3 for 1280; 3 = 1920/1280)
+ * @hbin_ratio: height downscale factor (e.g. 3 for 720; 3 = 1080/720)
+ * @min_frame_len: Minimum frame length for each mode (see "Frame Rate
+ *                 Adjustment (CSI-2)" in the datasheet)
+ * @min_SHR: Minimum SHR register value (see "Shutter Setting (CSI-2)" in the
+ *           datasheet)
+ * @max_fps: Maximum frames per second
+ * @nocpiop: Number of clocks per internal offset period (see "Integration Time
+ *           in Each Readout Drive Mode (CSI-2)" in the datasheet)
+ */
+struct ox03f10_mode {
+	const struct reg_8 *init_regs;
+	u8 wbin_ratio;
+	u8 hbin_ratio;
+	int min_frame_len;
+	int min_SHR;
+	int max_fps;
+	int nocpiop;
+};
+
+/* nocpiop happens to be the same number for the implemented modes */
+static const struct ox03f10_mode ox03f10_modes[] = {
+	{
+		/* mode 1, 2K */
+		.wbin_ratio = 1, /* 1920 */
+		.hbin_ratio = 1, /* 1080 */
+		.init_regs = ox03f10_mode1_1920x1080_raw12_37fps,
+		.min_frame_len = 0x330,
+		.min_SHR = 12,
+		.max_fps = 37,
+		.nocpiop = 112,
+	},
+};
+
+/*
+ * struct ox03f10_ctrls - ox03f10 ctrl structure
+ * @handler: V4L2 ctrl handler structure
+ * @exposure: Pointer to expsure ctrl structure
+ * @gain: Pointer to gain ctrl structure
+ */
+struct ox03f10_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *gain;
+};
+
+/**
+ * struct max96705_device - max96705 device
+ * @client: The i2c client for the max96705 instance
+ */
+struct max9295_device {
+	struct i2c_client *client;
+};
+
+/*
+ * struct st_ox03f10 - ox03f10 device structure
+ * @sd: V4L2 subdevice structure
+ * @pad: Media pad structure
+ * @client: Pointer to I2C client
+ * @ctrls: ox03f10 control structure
+ * @crop: rect to be captured
+ * @compose: compose rect, i.e. output resolution
+ * @format: V4L2 media bus frame format structure
+ *          (width and height are in sync with the compose rect)
+ * @frame_rate: V4L2 frame rate structure
+ * @regmap: Pointer to regmap structure
+ * @reset_gpio: Pointer to reset gpio
+ * @supplies: List of analog and digital supply regulators
+ * @inck: Pointer to sensor input clock
+ * @lock: Mutex structure
+ * @mode: Parameters for the selected readout mode
+ */
+struct st_ox03f10 {
+	struct device *dev;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct i2c_client *client;
+	struct ox03f10_ctrls ctrls;
+
+	struct max9295_device serializer;
+	struct i2c_client *sensor;
+	struct regmap *serializer_regmap;
+	u32 addrs[2];
+
+	struct v4l2_rect crop;
+	struct v4l2_mbus_framefmt format;
+	struct v4l2_fract frame_interval;
+	struct regmap *regmap;
+	struct gpio_desc *reset_gpio;
+	struct regulator_bulk_data supplies[OX03F10_NUM_SUPPLIES];
+	struct clk *inck;
+	struct mutex lock; /* mutex lock for operations */
+	const struct ox03f10_mode *mode;
+	int set_fps;
+
+};
+
+#define OX03F10_ROUND(dim, step, flags)			\
+	((flags) & V4L2_SEL_FLAG_GE			\
+	 ? roundup((dim), (step))			\
+	 : ((flags) & V4L2_SEL_FLAG_LE			\
+	    ? rounddown((dim), (step))			\
+	    : rounddown((dim) + (step) / 2, (step))))
+
+/*
+ * Function declaration
+ */
+static int ox03f10_set_gain(struct st_ox03f10 *priv, struct v4l2_ctrl *ctrl);
+static int ox03f10_set_exposure(struct st_ox03f10 *priv, int val);
+static int ox03f10_set_frame_interval(struct st_ox03f10 *priv,
+				      struct v4l2_fract frame_interval);
+
+
+/*
+ * v4l2_ctrl and v4l2_subdev related operations
+ */
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler,
+			     struct st_ox03f10, ctrls.handler)->sd;
+}
+
+static inline struct st_ox03f10 *to_ox03f10(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct st_ox03f10, sd);
+}
+
+/*
+ * Writing a register table
+ *
+ * @priv: Pointer to device
+ * @table: Table containing register values (with optional delays)
+ *
+ * This is used to write register table into sensor's reg map.
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int ox03f10_write_table(struct st_ox03f10 *priv, const struct reg_8 table[])
+{
+	struct regmap *regmap = priv->regmap;
+	int err = 0;
+	int i = 0;
+
+	for (i = 0; ; i++) {
+		if (table[i].addr == OX03F10_TABLE_WAIT) {
+			msleep(table[i].val);
+			continue;
+		}
+		if (table[i].addr == OX03F10_TABLE_END)
+			break;
+
+		err = regmap_write(regmap, table[i].addr, table[i].val);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static inline int ox03f10_write_reg(struct st_ox03f10 *priv, u16 addr, u8 val)
+{
+	int err;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(&priv->client->dev,
+			"%s : i2c write failed, %x = %x\n", __func__,
+			addr, val);
+	else
+		dev_dbg(&priv->client->dev,
+			"%s : addr 0x%x, val=0x%x\n", __func__,
+			addr, val);
+	return err;
+}
+
+static inline int ox03f10_read_reg(struct st_ox03f10 *priv, u16 addr, unsigned int *val)
+{
+	int err;
+
+	err = regmap_read(priv->regmap, addr, val);
+	if (err)
+		dev_err(&priv->client->dev,
+			"%s : i2c read failed, %x = %x\n", __func__,
+			addr, val);
+	else
+		dev_dbg(&priv->client->dev,
+			"%s : addr 0x%x, val=0x%x\n", __func__,
+			addr, val);
+	return err;
+}
+
+/*
+ * Set mode registers to start stream.
+ * @priv: Pointer to device structure
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int ox03f10_mode_regs(struct st_ox03f10 *priv)
+{
+	int err;
+
+	err = ox03f10_write_table(priv, priv->mode->init_regs);
+
+	return err;
+}
+
+/*
+ * ox03f10_start_stream - Function for starting stream per mode index
+ * @priv: Pointer to device structure
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int ox03f10_start_stream(struct st_ox03f10 *priv)
+{
+	int err = 0;
+	int frame_length = 0;
+	struct regmap *regmap = priv->regmap;
+
+	if (priv->set_fps != 1) {
+		err = regmap_write(regmap, 0x380e, 0x03);
+		if (err)
+			return err;
+
+		err = regmap_write(regmap, 0x380f, 0xee);
+		if (err)
+			return err;
+	}
+
+	err = ox03f10_write_table(priv, ox03f10_start);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ox03f10_power_on(struct device *dev)
+{
+	return 0;
+}
+
+static int ox03f10_power_off(struct device *dev)
+{
+	return 0;
+}
+
+/**
+ * ox03f10_s_ctrl - This is used to set the ox03f10 V4L2 controls
+ * @ctrl: V4L2 control to be set
+ *
+ * This function is used to set the V4L2 controls for the ox03f10 sensor.
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int ox03f10_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+	int ret = -EINVAL;
+
+	dev_dbg(&ox03f10->client->dev,
+		"%s : s_ctrl: %s, value: %d\n", __func__,
+		ctrl->name, ctrl->val);
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+		dev_dbg(&ox03f10->client->dev,
+			"%s : set V4L2_CID_EXPOSURE\n", __func__);
+		ret = ox03f10_set_exposure(ox03f10, ctrl->val);
+		break;
+
+	case V4L2_CID_GAIN:
+		dev_dbg(&ox03f10->client->dev,
+			"%s : set V4L2_CID_GAIN\n", __func__);
+		ret = ox03f10_set_gain(ox03f10, ctrl);
+		break;
+	}
+
+	return ret;
+}
+
+static int ox03f10_binning_goodness(struct st_ox03f10 *ox03f10,
+				    int w, int ask_w,
+				    int h, int ask_h, u32 flags)
+{
+	struct device *dev = &ox03f10->client->dev;
+	const int goodness = 100000;
+	int val = 0;
+
+	if (flags & V4L2_SEL_FLAG_GE) {
+		if (w < ask_w)
+			val -= goodness;
+
+		if (h < ask_h)
+			val -= goodness;
+	}
+
+	if (flags & V4L2_SEL_FLAG_LE) {
+		if (w > ask_w)
+			val -= goodness;
+
+		if (h > ask_h)
+			val -= goodness;
+	}
+
+	val -= abs(w - ask_w);
+	val -= abs(h - ask_h);
+
+	dev_dbg(dev, "%s: ask %dx%d, size %dx%d, goodness %d\n",
+		__func__, ask_w, ask_h, w, h, val);
+
+	return val;
+}
+
+/**
+ * __ox03f10_change_compose - Helper function to change binning and set both
+ *	compose and format.
+ *
+ * We have two entry points to change binning: set_fmt and
+ * set_selection(COMPOSE). Both have to compute the new output size
+ * and set it in both the compose rect and the frame format size. We
+ * also need to do the same things after setting cropping to restore
+ * 1:1 binning.
+ *
+ * This function contains the common code for these three cases, it
+ * has many arguments in order to accommodate the needs of all of
+ * them.
+ *
+ * Must be called with ox03f10->lock locked.
+ *
+ * @ox03f10: The device object
+ * @sd_state: The subdev state we are editing for TRY requests
+ * @which:  V4L2_SUBDEV_FORMAT_ACTIVE or V4L2_SUBDEV_FORMAT_TRY from the caller
+ * @width:  Input-output parameter: set to the desired width before
+ *          the call, contains the chosen value after returning successfully
+ * @height: Input-output parameter for height (see @width)
+ * @flags:  Selection flags from struct v4l2_subdev_selection, or 0 if not
+ *          available (when called from set_fmt)
+ */
+static int __ox03f10_change_compose(struct st_ox03f10 *ox03f10,
+				    struct v4l2_subdev_state *sd_state,
+				    u32 which,
+				    u32 *width,
+				    u32 *height,
+				    u32 flags)
+{
+	struct device *dev = &ox03f10->client->dev;
+	const struct v4l2_rect *cur_crop;
+	struct v4l2_mbus_framefmt *tgt_fmt;
+	unsigned int i;
+	const struct ox03f10_mode *best_mode = &ox03f10_modes[0];
+	int best_goodness = INT_MIN;
+
+	if (which == V4L2_SUBDEV_FORMAT_TRY) {
+		cur_crop = &sd_state->pads->try_crop;
+		tgt_fmt = &sd_state->pads->try_fmt;
+	} else {
+		cur_crop = &ox03f10->crop;
+		tgt_fmt = &ox03f10->format;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ox03f10_modes); i++) {
+		u8 wratio = ox03f10_modes[i].wbin_ratio;
+		u8 hratio = ox03f10_modes[i].hbin_ratio;
+
+		int goodness = ox03f10_binning_goodness(
+				       ox03f10,
+				       cur_crop->width / wratio, *width,
+				       cur_crop->height / hratio, *height,
+				       flags);
+
+		if (goodness >= best_goodness) {
+			best_goodness = goodness;
+			best_mode = &ox03f10_modes[i];
+		}
+	}
+
+	*width = cur_crop->width / best_mode->wbin_ratio;
+	*height = cur_crop->height / best_mode->hbin_ratio;
+
+	if (which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		ox03f10->mode = best_mode;
+
+	dev_dbg(dev, "%s: selected %ux%u binning\n",
+		__func__, best_mode->wbin_ratio, best_mode->hbin_ratio);
+
+	tgt_fmt->width = *width;
+	tgt_fmt->height = *height;
+	tgt_fmt->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+/**
+ * ox03f10_get_fmt - Get the pad format
+ * @sd: Pointer to V4L2 Sub device structure
+ * @sd_state: Pointer to sub device state structure
+ * @fmt: Pointer to pad level media bus format
+ *
+ * This function is used to get the pad format information.
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *fmt)
+{
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+
+	mutex_lock(&ox03f10->lock);
+	fmt->format = ox03f10->format;
+	mutex_unlock(&ox03f10->lock);
+
+	return 0;
+}
+
+/**
+ * ox03f10_set_fmt - This is used to set the pad format
+ * @sd: Pointer to V4L2 Sub device structure
+ * @sd_state: Pointer to sub device state information structure
+ * @format: Pointer to pad level media bus format
+ *
+ * This function is used to set the pad format.
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_state *sd_state,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *fmt = &format->format;
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+	int err = 0;
+
+	mutex_lock(&ox03f10->lock);
+
+	err = __ox03f10_change_compose(ox03f10, sd_state, format->which,
+				       &fmt->width, &fmt->height, 0);
+
+	if (err)
+		goto out;
+
+	/*
+	 * __ox03f10_change_compose already set width and height in the
+	 * applicable format, but we need to keep all other format
+	 * values, so do a full copy here
+	 */
+	fmt->field = V4L2_FIELD_NONE;
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		sd_state->pads->try_fmt = *fmt;
+	else
+		ox03f10->format = *fmt;
+
+out:
+	mutex_unlock(&ox03f10->lock);
+
+	return err;
+}
+
+static int ox03f10_get_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+	const struct v4l2_rect *src_crop;
+	const struct v4l2_mbus_framefmt *src_fmt;
+	int ret = 0;
+
+	if (sel->pad != 0)
+		return -EINVAL;
+
+	if (sel->target == V4L2_SEL_TGT_CROP_BOUNDS) {
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OX03F10_MAX_WIDTH;
+		sel->r.height = OX03F10_MAX_HEIGHT;
+		return 0;
+	}
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY) {
+		src_crop = &sd_state->pads->try_crop;
+		src_fmt = &sd_state->pads->try_fmt;
+	} else {
+		src_crop = &ox03f10->crop;
+		src_fmt = &ox03f10->format;
+	}
+
+	mutex_lock(&ox03f10->lock);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		sel->r = *src_crop;
+		break;
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = src_crop->width;
+		sel->r.height = src_crop->height;
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = src_fmt->width;
+		sel->r.height = src_fmt->height;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	mutex_unlock(&ox03f10->lock);
+
+	return ret;
+}
+static int ox03f10_set_selection_crop(struct st_ox03f10 *ox03f10,
+				      struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *tgt_crop;
+	struct v4l2_rect new_crop;
+	bool size_changed;
+
+	/*
+	 * h_step could be 12 or 24 depending on the binning. But we
+	 * won't know the binning until we choose the mode later in
+	 * __ox03f10_change_compose(). Thus let's be safe and use the
+	 * most conservative value in all cases.
+	 */
+	const u32 h_step = 24;
+
+	new_crop.width = min_t(u32,
+			       OX03F10_ROUND(sel->r.width, h_step, sel->flags),
+			       OX03F10_MAX_WIDTH);
+
+	/* Constraint: HTRIMMING_END - HTRIMMING_START >= 144 */
+	if (new_crop.width < 144)
+		new_crop.width = 144;
+
+	new_crop.left = min_t(u32,
+			      OX03F10_ROUND(sel->r.left, h_step, 0),
+			      OX03F10_MAX_WIDTH - new_crop.width);
+
+	new_crop.height = min_t(u32,
+				OX03F10_ROUND(sel->r.height, 2, sel->flags),
+				OX03F10_MAX_HEIGHT);
+
+	new_crop.top = min_t(u32, OX03F10_ROUND(sel->r.top, 2, 0),
+			     OX03F10_MAX_HEIGHT - new_crop.height);
+
+	sel->r = new_crop;
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		tgt_crop = &sd_state->pads->try_crop;
+	else
+		tgt_crop = &ox03f10->crop;
+
+	mutex_lock(&ox03f10->lock);
+
+	size_changed = (new_crop.width != tgt_crop->width ||
+			new_crop.height != tgt_crop->height);
+
+	/* __ox03f10_change_compose needs the new size in *tgt_crop */
+	*tgt_crop = new_crop;
+
+	/* if crop size changed then reset the output image size */
+	if (size_changed)
+		__ox03f10_change_compose(ox03f10, sd_state, sel->which,
+					 &new_crop.width, &new_crop.height,
+					 sel->flags);
+
+	mutex_unlock(&ox03f10->lock);
+
+	return 0;
+}
+
+
+static int ox03f10_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+
+	if (sel->pad != 0)
+		return -EINVAL;
+
+	if (sel->target == V4L2_SEL_TGT_CROP)
+		return ox03f10_set_selection_crop(ox03f10, sd_state, sel);
+
+	if (sel->target == V4L2_SEL_TGT_COMPOSE) {
+		int err;
+
+		mutex_lock(&ox03f10->lock);
+		err =  __ox03f10_change_compose(ox03f10, sd_state, sel->which,
+						&sel->r.width, &sel->r.height,
+						sel->flags);
+		mutex_unlock(&ox03f10->lock);
+
+		/*
+		 * __ox03f10_change_compose already set width and
+		 * height in set->r, we still need to set top-left
+		 */
+		if (!err) {
+			sel->r.top = 0;
+			sel->r.left = 0;
+		}
+
+		return err;
+	}
+
+	return -EINVAL;
+}
+
+/**
+ * ox03f10_g_frame_interval - Get the frame interval
+ * @sd: Pointer to V4L2 Sub device structure
+ * @fi: Pointer to V4l2 Sub device frame interval structure
+ *
+ * This function is used to get the frame interval.
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_g_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *fi)
+{
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+
+	fi->interval = ox03f10->frame_interval;
+	dev_dbg(&ox03f10->client->dev, "%s frame rate = %d / %d\n",
+		__func__, ox03f10->frame_interval.numerator,
+		ox03f10->frame_interval.denominator);
+
+	return 0;
+}
+
+/**
+ * ox03f10_s_frame_interval - Set the frame interval
+ * @sd: Pointer to V4L2 Sub device structure
+ * @fi: Pointer to V4l2 Sub device frame interval structure
+ *
+ * This function is used to set the frame intervavl.
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_s_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *fi)
+{
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+	struct v4l2_ctrl *ctrl = ox03f10->ctrls.exposure;
+	int min, max, def;
+	int ret;
+
+	mutex_lock(&ox03f10->lock);
+	ret = ox03f10_set_frame_interval(ox03f10, fi->interval);
+
+unlock:
+	mutex_unlock(&ox03f10->lock);
+	pm_runtime_put(&ox03f10->client->dev);
+
+	return ret;
+}
+
+/**
+ * ox03f10_load_default - load default control values
+ * @priv: Pointer to device structure
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static void ox03f10_load_default(struct st_ox03f10 *priv)
+{
+	/* load default control values */
+	priv->frame_interval.numerator = 1;
+	priv->frame_interval.denominator = OX03F10_DEF_FRAME_RATE;
+	priv->ctrls.exposure->val = 1000000 / OX03F10_DEF_FRAME_RATE;
+	priv->ctrls.gain->val = OX03F10_DEF_GAIN;
+}
+
+/*
+ * ox03f10_set_frame_length - Function called when setting frame length
+ * @priv: Pointer to device structure
+ * @val: Variable for frame length (= VMAX, i.e. vertical drive period length)
+ *
+ * Set frame length based on input value.
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_set_frame_length(struct st_ox03f10 *priv, u32 val)
+{
+	int err;
+	u32 frame_length, frame_length_rd = 0;
+
+	dev_dbg(&priv->client->dev, "%s : input length = %d\n",
+		__func__, val);
+
+	frame_length = (u32)val;
+
+	err = ox03f10_write_reg(priv, OX03F10_VTS_H,
+				(frame_length >> 8) & 0xff);
+	if (err)
+		goto fail;
+
+	err = ox03f10_write_reg(priv, OX03F10_VTS_L,
+				(frame_length) & 0xff);
+	if (err)
+		goto fail;
+
+	ox03f10_read_reg(priv, OX03F10_VTS_H, &frame_length_rd);
+	ox03f10_read_reg(priv, OX03F10_VTS_L, &frame_length_rd);
+
+	return 0;
+
+fail:
+	dev_err(&priv->client->dev, "%s error = %d\n", __func__, err);
+	return err;
+}
+
+/**
+ * ox03f10_s_stream - It is used to start/stop the streaming.
+ * @sd: V4L2 Sub device
+ * @on: Flag (True / False)
+ *
+ * This function controls the start or stop of streaming for the
+ * ox03f10 sensor.
+ *
+ * Return: 0 on success, errors otherwise
+ */
+static int ox03f10_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+	int ret = 0;
+	u32 frame_length_rd = 0;
+
+	dev_dbg(&ox03f10->client->dev, "%s : %s, mode index = %td\n", __func__,
+		on ? "Stream Start" : "Stream Stop",
+		ox03f10->mode - &ox03f10_modes[0]);
+
+	mutex_lock(&ox03f10->lock);
+	if (on) {
+		/* load mode registers */
+		//ret = ox03f10_mode_regs(ox03f10);
+		//if (ret)
+		//	goto fail;
+
+		/* start stream */
+		ret = ox03f10_start_stream(ox03f10);
+		if (ret)
+			goto fail;
+	} else {
+		/* stop stream */
+		ret = ox03f10_write_table(ox03f10, ox03f10_stop);
+		if (ret)
+			goto fail;
+	}
+	mutex_unlock(&ox03f10->lock);
+	return 0;
+
+fail:
+	mutex_unlock(&ox03f10->lock);
+	dev_err(&ox03f10->client->dev, "s_stream failed\n");
+	return ret;
+}
+
+/*
+ * ox03f10_set_gain - Function called when setting gain
+ * @priv: Pointer to device structure
+ * @val: Value of gain. the real value = val << OX03F10_GAIN_SHIFT;
+ * @ctrl: v4l2 control pointer
+ *
+ * Set the gain based on input value.
+ * The caller should hold the mutex lock ox03f10->lock if necessary
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_set_gain(struct st_ox03f10 *priv, struct v4l2_ctrl *ctrl)
+{
+	int err;
+	u32 gain;
+
+	gain = (u32)(ctrl->val);
+
+	if (gain > OX03F10_MAX_GAIN)
+		gain = OX03F10_MAX_GAIN;
+
+	if (gain < OX03F10_MIN_GAIN)
+		gain = OX03F10_MIN_GAIN;
+
+	err = ox03f10_write_reg(priv, OX03F10_GAIN_H, gain & 0xff);
+	if (err) {
+		dev_err(&priv->client->dev, "VFLIP control error\n");
+		return err;
+	}
+
+	return err;
+}
+
+/*
+ * ox03f10_set_coarse_time - Function called when setting SHR value
+ * @priv: Pointer to device structure
+ * @val: Value for exposure time in number of line_length, or [HMAX]
+ *
+ * Set SHR value based on input value.
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_set_coarse_time(struct st_ox03f10 *priv, u32 coarse_time)
+{
+	int err = 0;
+
+	if (coarse_time > priv->mode->min_frame_len)
+		coarse_time = priv->mode->min_frame_len;
+
+	err = ox03f10_write_reg(priv, OX03F10_EXPOSURE_H, (coarse_time >> 8) & 0xff);
+	if (err) {
+		dev_err(&priv->client->dev, "%s error\n", __func__);
+		return err;
+	}
+
+	err = ox03f10_write_reg(priv, OX03F10_EXPOSURE_L, coarse_time & 0xff);
+	if (err) {
+		dev_err(&priv->client->dev, "%s error\n", __func__);
+		return err;
+	}
+
+	return err;
+}
+
+/*
+ * ox03f10_set_exposure - Function called when setting exposure time
+ * @priv: Pointer to device structure
+ * @val: Variable for exposure time, in the unit of micro-second
+ *
+ * Set exposure time based on input value.
+ * The caller should hold the mutex lock ox03f10->lock if necessary
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_set_exposure(struct st_ox03f10 *priv, int val)
+{
+	int err;
+	u32 coarse_time; /* exposure time in unit of line (HMAX)*/
+
+	dev_dbg(&priv->client->dev,
+		"%s : EXPOSURE control input = %d\n", __func__, val);
+
+	coarse_time = val * priv->mode->min_frame_len * OX03F10_DEF_FRAME_RATE / 1000000;
+
+	err = ox03f10_set_coarse_time(priv, coarse_time);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+/*
+ * ox03f10_set_frame_interval - Function called when setting frame interval
+ * @priv: Pointer to device structure
+ * @frame_interval: Variable for frame interval
+ *
+ * Change frame interval by updating VMAX value
+ * The caller should hold the mutex lock ox03f10->lock if necessary
+ *
+ * Return: 0 on success
+ */
+static int ox03f10_set_frame_interval(struct st_ox03f10 *priv,
+				      struct v4l2_fract frame_interval)
+{
+	int err;
+	u32 frame_length, req_frame_rate;
+
+	dev_dbg(&priv->client->dev, "%s: input frame interval = %d / %d",
+		__func__, frame_interval.numerator,
+		frame_interval.denominator);
+
+
+	if (frame_interval.numerator == 0 || frame_interval.denominator == 0) {
+		frame_interval.denominator = OX03F10_DEF_FRAME_RATE;
+		frame_interval.numerator = 1;
+	}
+
+	req_frame_rate = (u32)(frame_interval.denominator
+			       / frame_interval.numerator);
+
+	/* boundary check */
+	if (req_frame_rate > priv->mode->max_fps) {
+		frame_interval.numerator = 1;
+		frame_interval.denominator = priv->mode->max_fps;
+	} else if (req_frame_rate < OX03F10_MIN_FRAME_RATE) {
+		frame_interval.numerator = 1;
+		frame_interval.denominator = OX03F10_MIN_FRAME_RATE;
+	}
+
+	frame_length = OX03F10_DEFAULT_FRAME_LENGTH * OX03F10_DEF_FRAME_RATE
+		       * frame_interval.numerator
+		       / frame_interval.denominator;
+
+	err = ox03f10_set_frame_length(priv, frame_length);
+	priv->set_fps = 1;
+	if (err)
+		goto fail;
+
+	priv->frame_interval = frame_interval;
+	return 0;
+
+fail:
+	dev_err(&priv->client->dev, "%s error = %d\n", __func__, err);
+	return err;
+}
+static const struct v4l2_subdev_pad_ops ox03f10_pad_ops = {
+	.get_fmt = ox03f10_get_fmt,
+	.set_fmt = ox03f10_set_fmt,
+	.get_selection = ox03f10_get_selection,
+	.set_selection = ox03f10_set_selection,
+};
+
+static const struct v4l2_subdev_video_ops ox03f10_video_ops = {
+	.g_frame_interval = ox03f10_g_frame_interval,
+	.s_frame_interval = ox03f10_s_frame_interval,
+	.s_stream = ox03f10_s_stream,
+};
+
+static const struct v4l2_subdev_ops ox03f10_subdev_ops = {
+	.pad = &ox03f10_pad_ops,
+	.video = &ox03f10_video_ops,
+};
+
+static const struct v4l2_ctrl_ops ox03f10_ctrl_ops = {
+	.s_ctrl	= ox03f10_s_ctrl,
+};
+
+static const struct of_device_id ox03f10_of_id_table[] = {
+	{ .compatible = "leopard,ox03f10" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ox03f10_of_id_table);
+
+static const struct i2c_device_id ox03f10_id[] = {
+	{ "OX03F10", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ox03f10_id);
+
+/*
+ * max929x_write_reg - Function called when write register to GMSL2 device
+ * @i2c_client: Pointer to i2c_client device
+ * @slave_addr: device slave addr
+ * @reg: device register addr
+ * @val: register val
+ *
+ * write val to gmsl2 device.
+ *
+ * Return: 0 on success
+ */
+static int max929x_write_reg(struct i2c_client *i2c_client, u8 slave_addr, u16 reg, u8 val)
+{
+	struct i2c_client *client = i2c_client;
+	struct device *dev = &client->dev;
+	struct i2c_msg msgs[1];
+	u8 send_buf[3];
+	int ret;
+	char temp;
+	int back_addr = client->addr;
+
+	client->addr = slave_addr;
+	send_buf[0] = reg >> 8;
+	send_buf[1] = reg & 0xff;
+	send_buf[2] = val & 0xff;
+
+	msgs[0].addr = client->addr;
+	msgs[0].len = 3;
+	msgs[0].buf = send_buf;
+	msgs[0].flags = 0;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+
+	if (ret != ARRAY_SIZE(msgs)) {
+		dev_err(dev, "Failed to write register, ret = %d\n", ret);
+		client->addr = back_addr;
+		return ret < 0 ? ret : -EIO;
+	}
+
+	msleep(50);
+	client->addr = back_addr;
+
+	return 0;
+}
+
+
+static int max9295_write(struct st_ox03f10 *priv, u16 reg, u8 val)
+{
+	int ret;
+
+	ret = regmap_write(priv->serializer_regmap, reg, val);
+	if (ret < 0)
+		dev_err(&priv->client->dev,
+			"%s: register 0x%02x write failed (%d)\n",
+			__func__, reg, ret);
+	return ret;
+}
+
+static int max9295_read(struct st_ox03f10 *priv, u16 reg, unsigned int *val)
+{
+	int ret;
+
+	ret = regmap_read(priv->serializer_regmap, reg, val);
+	if (ret < 0)
+		dev_err(&priv->client->dev,
+			"%s: register 0x%02x read failed (%d)\n",
+			__func__, reg, ret);
+	return ret;
+}
+
+
+int max9295_set_address(struct st_ox03f10 *dev, u8 addr)
+{
+	int ret;
+
+	ret = max9295_write(dev, 0x0000, addr << 1);
+	if (ret < 0) {
+		dev_err(&dev->client->dev,
+			"MAX96705 I2C address change failed (%d)\n", ret);
+		return ret;
+	}
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+
+int max9295_set_translation(struct st_ox03f10 *dev, u8 source, u8 dest)
+{
+	int ret;
+
+	ret = max9295_write(dev, 0x09, source << 1);
+	if (ret < 0) {
+		dev_err(&dev->client->dev,
+			"MAX96705 I2C translation setup failed (%d)\n", ret);
+		return ret;
+	}
+	usleep_range(3500, 5000);
+
+	ret = max9295_write(dev, 0x0a, dest << 1);
+	if (ret < 0) {
+		dev_err(&dev->client->dev,
+			"MAX96705 I2C translation setup failed (%d)\n", ret);
+		return ret;
+	}
+	usleep_range(3500, 5000);
+
+	return 0;
+}
+
+static int ox03f10_probe(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd;
+	struct st_ox03f10 *ox03f10;
+	int ret;
+	int gain = 2;
+	int i = 0;
+	int cam_link;
+
+	ox03f10 = devm_kzalloc(&client->dev, sizeof(*ox03f10), GFP_KERNEL);
+	if (!ox03f10)
+		return -ENOMEM;
+
+	ox03f10->dev = &client->dev;
+	mutex_init(&ox03f10->lock);
+
+	ox03f10->serializer.client = client;
+	ox03f10->set_fps = 0;
+
+	ret = of_property_read_u32_array(client->dev.of_node, "reg",
+					 ox03f10->addrs, 2);
+
+	if (ret < 0) {
+		dev_err(ox03f10->dev,
+			"Invalid DT reg property: %d\n", ret);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(client->dev.of_node, "link", &cam_link);
+	i2c_smbus_read_byte(ox03f10->serializer.client);
+
+	ret = max929x_write_reg(ox03f10->serializer.client,
+				MAX9295_DEFAULT_ADDR,
+				0x0000, ox03f10->addrs[0] << 1);
+	if (ret < 0) {
+		ret = max929x_write_reg(ox03f10->serializer.client,
+					ox03f10->addrs[0],
+					0x0000, ox03f10->addrs[0] << 1);
+		if (ret < 0)
+			return -EPROBE_DEFER;
+	}
+
+	for (i = 0; ; i++) {
+		if ((ser_init_a[i].addr == MAX929X_TABLE_END) ||
+		    (ser_init_b[i].addr == MAX929X_TABLE_END))
+			break;
+
+		if ((ser_init_a[i].addr == MAX929X_TABLE_WAIT) ||
+		    (ser_init_b[i].addr == MAX929X_TABLE_END)) {
+			msleep(ser_init_a[i].val);
+			continue;
+		}
+
+		if (cam_link == 1) {
+			ret = max929x_write_reg(ox03f10->serializer.client,
+						ox03f10->addrs[0],
+						ser_init_a[i].addr,
+						ser_init_a[i].val);
+			if (ret) {
+				dev_info(ox03f10->dev,
+					 "Serializer write failed !\n");
+				return -EPROBE_DEFER;
+			}
+		} else {
+			ret = max929x_write_reg(ox03f10->serializer.client,
+						ox03f10->addrs[0],
+						ser_init_b[i].addr,
+						ser_init_b[i].val);
+			if (ret) {
+				dev_info(ox03f10->dev,
+					 "Serializer write failed !\n");
+				return -EPROBE_DEFER;
+			}
+		}
+	}
+
+	/* This is for debug also verify write to new serializer address */
+	ret = max929x_write_reg(ox03f10->serializer.client,
+				ox03f10->addrs[0], 0x0053, 0x20);
+
+	/* Change sensor source and destination address */
+	ret = max929x_write_reg(ox03f10->serializer.client,
+				ox03f10->addrs[0], 0x0042,
+				ox03f10->addrs[1] << 1);
+	/* Change serializer address */
+	ret = max929x_write_reg(ox03f10->serializer.client,
+				ox03f10->addrs[0], 0x0043,
+				(SENSOR_DEFAULT_ADDRESS << 1));
+	if (ret < 0)	{
+		dev_info(ox03f10->dev, "Set address failed!\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* Create the dummy I2C client for the sensor. */
+	ox03f10->sensor = i2c_new_dummy_device(client->adapter,
+					       ox03f10->addrs[1]);
+	if (IS_ERR(ox03f10->sensor)) {
+		ret = PTR_ERR(ox03f10->sensor);
+		goto err_regmap;
+	}
+
+	ox03f10->mode = &ox03f10_modes[0];
+
+	ox03f10->crop.width = OX03F10_MAX_WIDTH;
+	ox03f10->crop.height = OX03F10_MAX_HEIGHT;
+
+	ox03f10->format.width = ox03f10->crop.width
+				/ox03f10->mode->wbin_ratio;
+	ox03f10->format.height = ox03f10->crop.height
+				 /ox03f10->mode->hbin_ratio;
+
+	ox03f10->format.field = V4L2_FIELD_NONE;
+
+	ox03f10->format.code = MEDIA_BUS_FMT_SGRBG12_1X12;
+	ox03f10->format.colorspace = V4L2_COLORSPACE_SRGB;
+
+	ox03f10->frame_interval.numerator = 1;
+	ox03f10->frame_interval.denominator = OX03F10_DEF_FRAME_RATE;
+
+	ox03f10->regmap = devm_regmap_init_i2c(ox03f10->sensor,
+					       &ox03f10_regmap_config);
+	if (IS_ERR(ox03f10->regmap)) {
+		dev_err(&client->dev, "regmap init failed: %ld\n",
+			PTR_ERR(ox03f10->regmap));
+		ret = -ENODEV;
+		goto err_regmap;
+	}
+
+	ret = ox03f10_write_reg(ox03f10, OX03F10_GAIN_H, gain & 0xff);
+
+	ret = ox03f10_mode_regs(ox03f10);
+	if (ret)
+		dev_info(ox03f10->dev, "Apply the register settings for ox03f10 senor\n");
+
+	if (ret) {
+		dev_info(ox03f10->dev, "ox03f10 sensor write failed\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* Initialize subdevice */
+	ox03f10->client = client;
+	ox03f10->client->addr = ox03f10->addrs[0];
+
+	sd = &ox03f10->sd;
+	v4l2_i2c_subdev_init(sd, client, &ox03f10_subdev_ops);
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+
+	/* Initialize subdev media pad */
+	ox03f10->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sd->entity, 1, &ox03f10->pad);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"%s : media entity init Failed %d\n", __func__, ret);
+		goto err_regmap;
+	}
+
+	/* Initialize controls */
+	ret = v4l2_ctrl_handler_init(&ox03f10->ctrls.handler, 2);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"%s : ctrl handler init Failed\n", __func__);
+		goto err_power_off;
+	}
+
+	ox03f10->ctrls.handler.lock = &ox03f10->lock;
+
+	/* Add new controls */
+	ox03f10->ctrls.gain = v4l2_ctrl_new_std(
+				      &ox03f10->ctrls.handler,
+				      &ox03f10_ctrl_ops,
+				      V4L2_CID_GAIN, OX03F10_MIN_GAIN,
+				      OX03F10_MAX_GAIN, 1,
+				      OX03F10_DEF_GAIN);
+
+	ox03f10->ctrls.exposure = v4l2_ctrl_new_std(
+					  &ox03f10->ctrls.handler,
+					  &ox03f10_ctrl_ops,
+					  V4L2_CID_EXPOSURE, OX03F10_MIN_EXPOSURE_TIME,
+					  1000000 / OX03F10_DEF_FRAME_RATE, 1,
+					  OX03F10_MIN_EXPOSURE_TIME);
+
+
+	ox03f10->sd.ctrl_handler = &ox03f10->ctrls.handler;
+	if (ox03f10->ctrls.handler.error) {
+		ret = ox03f10->ctrls.handler.error;
+		goto err_ctrls;
+	}
+
+	/* Load default control values */
+	ox03f10_load_default(ox03f10);
+
+	msleep(10);
+	/* Register subdevice */
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"%s : v4l2_async_register_subdev failed %d\n",
+			__func__, ret);
+		goto err_ctrls;
+	}
+
+	dev_info(&client->dev, "OX03F10 Probe Success\n");
+	return 0;
+
+err_ctrls:
+	v4l2_ctrl_handler_free(&ox03f10->ctrls.handler);
+err_power_off:
+	ox03f10_power_off(&client->dev);
+err_regmap:
+	media_entity_cleanup(&sd->entity);
+	if (ox03f10->sensor)
+		i2c_unregister_device(ox03f10->sensor);
+	mutex_destroy(&ox03f10->lock);
+
+	return ret;
+}
+
+static void ox03f10_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct st_ox03f10 *ox03f10 = to_ox03f10(sd);
+
+	ox03f10_power_off(&client->dev);
+
+	v4l2_async_unregister_subdev(sd);
+	v4l2_ctrl_handler_free(&ox03f10->ctrls.handler);
+	media_entity_cleanup(&sd->entity);
+	i2c_unregister_device(ox03f10->sensor);
+	mutex_destroy(&ox03f10->lock);
+}
+
+static const struct dev_pm_ops ox03f10_pm_ops = {
+	SET_RUNTIME_PM_OPS(ox03f10_power_off, ox03f10_power_on, NULL)
+};
+
+static struct i2c_driver ox03f10_i2c_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.pm = &ox03f10_pm_ops,
+		.of_match_table	= ox03f10_of_id_table,
+	},
+	.probe_new	= ox03f10_probe,
+	.remove		= ox03f10_remove,
+	.id_table	= ox03f10_id,
+};
+
+module_i2c_driver(ox03f10_i2c_driver);
+
+MODULE_AUTHOR("Weicen Zhou <weicenz@leopardimaging.com>");
+MODULE_AUTHOR("Amit Verma <amit.verma@amd.com");
+MODULE_DESCRIPTION("OX03F10 CMOS Image Sensor and max9295 serializer driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/ox03f10_tables.h b/drivers/media/i2c/ox03f10_tables.h
new file mode 100644
index 0000000..0a031a0
--- /dev/null
+++ b/drivers/media/i2c/ox03f10_tables.h
@@ -0,0 +1,1776 @@
+#ifndef __LI_OX03F10__
+#define __LI_OX03F10__
+
+#define MAX929X_TABLE_END			(0xffff)
+#define MAX929X_TABLE_WAIT			(0xfffe)
+#define MAX929X_TABLE_WAIT_MS			(210)
+
+/*
+ * See "SHR, SVR Setting" in datasheet
+ */
+#define OX03F10_DEFAULT_FRAME_LENGTH		(0x330)
+#define OX03F10_MAX_FRAME_LENGTH		(0x330)
+
+/*
+ * See "Analog Gain" and "Digital Gain" in datasheet
+ * min gain is 1X
+ * max gain is calculated based on OX03F10_GAIN_REG_MAX
+ */
+
+#define OX03F10_MIN_GAIN			(0x01)
+#define OX03F10_MAX_GAIN			(0x0f)
+#define OX03F10_DEF_GAIN			(1)
+
+/*
+ * 1 line time in us = (HTS / SCLK), minimal is 12 lines
+ */
+#define OX03F10_MIN_EXPOSURE_TIME		(12 * 1211 / 138)
+
+#define OX03F10_MAX_WIDTH			(1920)
+#define OX03F10_MAX_HEIGHT			(1080)
+#define OX03F10_MAX_FRAME_RATE			(37)
+#define OX03F10_MIN_FRAME_RATE			(1)
+#define OX03F10_DEF_FRAME_RATE			(37)
+
+/*
+ * register SHR is limited to (SVR value + 1) x VMAX value - 4
+ */
+#define OX03F10_SHR_LIMIT_CONST			(4)
+
+#define DRIVER_NAME "OX03F10"
+
+/*
+ * OX03F10 register definitions
+ */
+#define OX03F10_TABLE_END			(0xffff)
+#define OX03F10_TABLE_WAIT			(0xfffe)
+#define OX03F10_TABLE_WAIT_MS			(210)
+#define DSER_ADDR				(0x68) /* 7bit */
+#define SER_ADDR				(0x62) /* 7bit */
+
+
+#define OX03F10_EXPOSURE_H			(0x3501)
+#define OX03F10_EXPOSURE_L			(0x3502)
+#define OX03F10_GAIN_H				(0x350a)
+#define OX03F10_GAIN_M				(0x350b)
+#define OX03F10_GAIN_L				(0x350c)
+
+/*
+ * ox03f10 I2C operation related structure
+ */
+struct reg_8 {
+	u16 addr;
+	u8 val;
+};
+
+struct reg_8 ser_init_a[] = {
+	{0x0053, 0x10},
+	{0x0057, 0x11},
+	{0x005B, 0x12},
+	{0x005F, 0x13},
+	//Color BPP (VIDEO_TX1)
+	{0x0101, 0x4C},
+	{0x0109, 0x0C},
+	{0x0111, 0x4C},
+	{0x0119, 0x4C},
+
+	{0x0330, 0x00},
+	{0x0331, 0x33},
+	{0x0332, 0xe0},
+	{0x0333, 0x04},
+	{0x0119, 0x4C},
+	//Designated datatype to route to video pipeline (FRONTTOP_12 ...)
+	{0x0314, 0x00},
+	//{0x0316, 0x5E},  YUV
+	{0x0316, 0x00},
+	{0x0318, 0x6C},
+	{0x031A, 0x00},
+	{0x02be, 0x90}, // VC and DT destination map 1
+	//Enable CSI port B, CSI port B selection for video pipeline Y (FRONTTOP_0)
+	{0x0308, 0x7F},
+	//Start video pipe Y from CSI port B (FRONTTOP_9)
+	{0x0311, 0x25},
+	//Video transmit enable for pipeline Y
+	{0x0002, 0xF3},
+	{0x02be, 0x90}, /* RESET Sensor */
+	{MAX929X_TABLE_WAIT, MAX929X_TABLE_WAIT_MS},
+	{MAX929X_TABLE_END, 0}
+};
+
+struct reg_8 ser_init_b[] = {
+	{0x0053, 0x10},
+	{0x0057, 0x12},
+	{0x005B, 0x11},
+	{0x005F, 0x13},
+	//Color BPP (VIDEO_TX1)
+	{0x0101, 0x4C},
+	{0x0109, 0x0C},
+	{0x0111, 0x4C},
+	{0x0119, 0x4C},
+
+	{0x0330, 0x00},
+	{0x0331, 0x33},
+	{0x0332, 0xe0},
+	{0x0333, 0x04},
+	{0x0119, 0x4C},
+	//Designated datatype to route to video pipeline (FRONTTOP_12 ...)
+	{0x0314, 0x00},
+	//{0x0316, 0x5E},  YUV
+	{0x0316, 0x00},
+	{0x0318, 0x6C},
+	{0x031A, 0x00},
+	{0x02be, 0x90}, // VC and DT destination map 1
+	//Enable CSI port B, CSI port B selection for video pipeline Y (FRONTTOP_0)
+	{0x0308, 0x7F},
+	//Start video pipe Y from CSI port B (FRONTTOP_9)
+	{0x0311, 0x25},
+	//Video transmit enable for pipeline Y
+	{0x0002, 0xF3},
+	{0x02be, 0x90}, /* RESET Sensor */
+	{MAX929X_TABLE_WAIT, MAX929X_TABLE_WAIT_MS},
+	{MAX929X_TABLE_END, 0}
+};
+
+/* 1920x1080_34fps */
+struct reg_8 ox03f10_mode1_1920x1080_raw12_37fps[] = {
+	{0x0103, 0x01},
+	{0x0107, 0x01},
+	{0x4d5a, 0x1a},
+	{0x4d09, 0xff},
+	{0x4d09, 0xdf},
+	{0x3208, 0x04},
+	{0x4620, 0x04},
+	{0x3208, 0x14},
+	{0x3208, 0x05},
+	{0x4620, 0x04},
+	{0x3208, 0x15},
+	{0x3208, 0x02},
+	{0x3507, 0x00},
+	{0x3208, 0x12},
+	{0x3208, 0xa2},
+	{0x0301, 0xc8},
+	{0x0303, 0x01},
+	{0x0304, 0x00},
+	{0x0305, 0xaa},
+	{0x0306, 0x04},
+	{0x0307, 0x00},
+	{0x0308, 0x13},
+	{0x0316, 0x00},
+	{0x0318, 0x00},
+	{0x0320, 0x02},
+	{0x0321, 0x31},
+	{0x0323, 0x05},
+	{0x0324, 0x03},
+	{0x0325, 0x20},
+	{0x0408, 0xe0},
+	{0x0409, 0x7e},
+	{0x040a, 0xde},
+	{0x040b, 0x34},
+	{0x040c, 0x3f},
+	{0x040d, 0x63},
+	{0x040e, 0x08},
+	{0x2803, 0xfe},
+	{0x280b, 0x00},
+	{0x280c, 0x79},
+	{0x3002, 0xfc},
+	{0x3012, 0x41},
+	{0x3022, 0x88},
+	{0x3703, 0x34},
+	{0x3705, 0x00},
+	{0x3706, 0x33},
+	{0x3707, 0x0f},
+	{0x370a, 0x00},
+	{0x370b, 0x6d},
+	{0x3712, 0x13},
+	{0x3717, 0x07},
+	{0x3719, 0x3c},
+	{0x372c, 0x40},
+	{0x372d, 0x37},
+	{0x3730, 0x23},
+	{0x3733, 0x01},
+	{0x3738, 0x48},
+	{0x3739, 0x48},
+	{0x373a, 0x3d},
+	{0x373b, 0x35},
+	{0x373f, 0x21},
+	{0x3740, 0x21},
+	{0x3741, 0x21},
+	{0x3742, 0x21},
+	{0x3750, 0x4f},
+	{0x3755, 0x1e},
+	{0x3756, 0x0f},
+	{0x3757, 0x20},
+	{0x3759, 0x28},
+	{0x375a, 0x00},
+	{0x375b, 0x53},
+	{0x376c, 0x07},
+	{0x3778, 0x20},
+	{0x377c, 0xc8},
+	{0x3781, 0x02},
+	{0x3782, 0x08},
+	{0x3783, 0x02},
+	{0x3784, 0x0a},
+	{0x3785, 0x0e},
+	{0x379c, 0x58},
+	{0x379e, 0x00},
+	{0x379f, 0x00},
+	{0x37a0, 0x00},
+	{0x37bc, 0x22},
+	{0x37c0, 0x01},
+	{0x37c4, 0x4d},
+	{0x37c5, 0x4c},
+	{0x37c6, 0x40},
+	{0x37c7, 0x3e},
+	{0x37c8, 0x02},
+	{0x37c9, 0x16},
+	{0x37d0, 0x00},
+	{0x37d1, 0x28},
+	{0x37d2, 0x00},
+	{0x37d3, 0x55},
+	{0x37d5, 0x27},
+	{0x37d6, 0x00},
+	{0x37d7, 0x52},
+	{0x3c03, 0x01},
+	{0x3c04, 0x01},
+	{0x3c06, 0x21},
+	{0x3c08, 0x01},
+	{0x3c09, 0x01},
+	{0x3c0a, 0x01},
+	{0x3c0b, 0x21},
+	{0x3c12, 0xc0},
+	{0x3c13, 0x21},
+	{0x3c14, 0x81},
+	{0x3c16, 0x13},
+	{0x3c21, 0x00},
+	{0x3c22, 0xf3},
+	{0x3c37, 0x12},
+	{0x3c38, 0x36},
+	{0x3c3d, 0x03},
+	{0x3c4c, 0x20},
+	{0x3c4d, 0x24},
+	{0x3c57, 0x21},
+	{0x3c5f, 0x04},
+	{0x3c62, 0x0a},
+	{0x3c71, 0x34},
+	{0x3c72, 0x34},
+	{0x3c73, 0x34},
+	{0x3c74, 0x03},
+	{0x3c76, 0x12},
+	{0x3106, 0x10},
+	{0x3215, 0xcd},
+	{0x3219, 0x08},
+	{0x3304, 0x04},
+	{0x3306, 0x03},
+	{0x3307, 0x00},
+	{0x3308, 0x00},
+	{0x3309, 0x00},
+	{0x330a, 0x00},
+	{0x330b, 0x00},
+	{0x330c, 0x00},
+	{0x330d, 0x00},
+	{0x330e, 0x00},
+	{0x330f, 0x00},
+	{0x3310, 0x06},
+	{0x3311, 0x05},
+	{0x3312, 0x55},
+	{0x3313, 0x02},
+	{0x3314, 0xaa},
+	{0x3315, 0x07},
+	{0x3316, 0xf0},
+	{0x3317, 0x00},
+	{0x3318, 0x00},
+	{0x3400, 0x08},
+	{0x3502, 0x08},
+	{0x3506, 0x30},
+	{0x3586, 0x50},
+	{0x3589, 0x00},
+	{0x3541, 0x00},
+	{0x3542, 0x04},
+	{0x3548, 0x04},
+	{0x3549, 0x40},
+	{0x35c1, 0x00},
+	{0x35c2, 0x02},
+	{0x35c6, 0xa0},
+	{0x3604, 0x91},
+	{0x3605, 0x1e},
+	{0x3607, 0x06},
+	{0x3609, 0xf0},
+	{0x360a, 0x01},
+	{0x360f, 0x00},
+	{0x3610, 0x70},
+	{0x3611, 0x3a},
+	{0x3612, 0x28},
+	{0x361a, 0x31},
+	{0x361b, 0x6c},
+	{0x361c, 0x0b},
+	{0x361d, 0x00},
+	{0x361e, 0xfa},
+	{0x361f, 0xcb},
+	{0x362b, 0x44},
+	{0x3639, 0x06},
+	{0x363a, 0x0a},
+	{0x363b, 0x14},
+	{0x363c, 0x26},
+	{0x363f, 0x00},
+	{0x3640, 0x30},
+	{0x3641, 0x20},
+	{0x3642, 0x30},
+	{0x3643, 0x02},
+	{0x3644, 0x0f},
+	{0x3645, 0x8c},
+	{0x3646, 0xcf},
+	{0x3648, 0x0c},
+	{0x3649, 0x06},
+	{0x364a, 0x04},
+	{0x364b, 0x02},
+	{0x364c, 0x18},
+	{0x364d, 0x13},
+	{0x364f, 0x10},
+	{0x3653, 0x1f},
+	{0x3654, 0x02},
+	{0x3655, 0x1f},
+	{0x3656, 0x1f},
+	{0x3657, 0x0e},
+	{0x3658, 0x0a},
+	{0x3659, 0x15},
+	{0x365a, 0x19},
+	{0x365b, 0x10},
+	{0x365c, 0x16},
+	{0x365d, 0x0b},
+	{0x365e, 0x0c},
+	{0x365f, 0x01},
+	{0x3660, 0x39},
+	{0x3661, 0xbf},
+	{0x3662, 0x0b},
+	{0x3664, 0x00},
+	{0x3667, 0x03},
+	{0x3668, 0x10},
+	{0x3669, 0x12},
+	{0x3674, 0x08},
+	{0x3677, 0x3a},
+	{0x3678, 0x3a},
+	{0x3800, 0x00},
+	{0x3801, 0x00},
+	{0x3802, 0x00},
+	{0x3803, 0x04},
+	{0x3806, 0x06},
+	{0x3807, 0x0b},
+	{0x3808, 0x07},
+	{0x3809, 0x80},
+	{0x380a, 0x04},
+	{0x380b, 0x38},
+	{0x380c, 0x04},
+	{0x380d, 0x01},
+	{OX03F10_TABLE_WAIT, OX03F10_TABLE_WAIT_MS},
+	{0x3810, 0x00},
+	{0x3811, 0x08},
+	{0x3812, 0x00},
+	{0x3813, 0x04},
+	{0x381c, 0x18},
+	{0x3820, 0x00},
+	{0x3821, 0x19},
+	{0x3832, 0x10},
+	{0x3834, 0xf0},
+	{0x383c, 0x48},
+	{0x383d, 0x00},
+	{0x384c, 0x01},
+	{0x384d, 0xf4},
+	{0x3850, 0x00},
+	{0x3851, 0x42},
+	{0x3852, 0x00},
+	{0x3853, 0x40},
+	{0x3858, 0x04},
+	{0x388c, 0x01},
+	{0x388d, 0xf4},
+	{0x3b40, 0x05},
+	{0x3b41, 0x20},
+	{0x3b42, 0x00},
+	{0x3b43, 0x90},
+	{0x3b44, 0x00},
+	{0x3b45, 0x20},
+	{0x3b46, 0x00},
+	{0x3b47, 0x20},
+	{0x3b48, 0x19},
+	{0x3b49, 0x12},
+	{0x3b4a, 0x16},
+	{0x3b4b, 0x2e},
+	{0x3b4c, 0x00},
+	{0x3b4d, 0x00},
+	{0x3b8a, 0x06},
+	{0x3b8b, 0x00},
+	{0x3b8c, 0x07},
+	{0x3b8d, 0x80},
+	{0x3b92, 0x06},
+	{0x3b93, 0x00},
+	{0x3b94, 0x07},
+	{0x3b95, 0x80},
+	{0x3b9e, 0x09},
+	{0x3d85, 0x05},
+	{0x3d8a, 0x03},
+	{0x3d8b, 0xff},
+	{0x3d99, 0x00},
+	{0x3d9a, 0x9f},
+	{0x3d9b, 0x00},
+	{0x3d9c, 0xa0},
+	{0x3da4, 0x00},
+	{0x3da7, 0x50},
+	{0x421e, 0x02},
+	{0x421f, 0x55},
+	{0x4220, 0xe1},
+	{0x4221, 0x01},
+	{0x4307, 0x03},
+	{0x4308, 0x13},
+	{0x430a, 0x13},
+	{0x430d, 0x93},
+	{0x430f, 0x17},
+	{0x4310, 0x95},
+	{0x4311, 0x16},
+	{0x4316, 0x00},
+	{0x4317, 0x08},
+	{0x4319, 0x03},
+	{0x431a, 0x00},
+	{0x431b, 0x00},
+	{0x431d, 0x2a},
+	{0x431e, 0x11},
+	{0x431f, 0x20},
+	{0x4320, 0x19},
+	{0x4323, 0x80},
+	{0x4324, 0x00},
+	{0x4503, 0x4e},
+	{0x4504, 0x1a},
+	{0x4505, 0x00},
+	{0x4507, 0x02},
+	{0x4508, 0x04},
+	{0x4509, 0x00},
+	{0x450a, 0x00},
+	{0x4580, 0xf8},
+	{0x4583, 0x07},
+	{0x4584, 0x6a},
+	{0x4585, 0x08},
+	{0x4586, 0x05},
+	{0x4587, 0x04},
+	{0x4588, 0x73},
+	{0x4589, 0x05},
+	{0x458a, 0x1f},
+	{0x458b, 0x02},
+	{0x458c, 0xdc},
+	{0x458d, 0x03},
+	{0x458e, 0x02},
+	{0x4597, 0x07},
+	{0x4598, 0x40},
+	{0x4599, 0x0c},
+	{0x459a, 0x0c},
+	{0x459b, 0xfa},
+	{0x459c, 0xf3},
+	{0x4602, 0x00},
+	{0x4603, 0x13},
+	{0x4604, 0x00},
+	{0x460a, 0x30},
+	{0x4610, 0x00},
+	{0x4611, 0x70},
+	{0x4612, 0x01},
+	{0x4613, 0x00},
+	{0x4614, 0x00},
+	{0x4615, 0x70},
+	{0x4616, 0x01},
+	{0x4617, 0x00},
+	{0x4627, 0xfd},
+	{0x4628, 0x33},
+	{0x4629, 0xc5},
+	{0x462a, 0x9e},
+	{0x4800, 0x04},
+	{0x4808, 0x18},
+	{0x480a, 0x22},
+	{0x4813, 0xe4},
+	{0x4837, 0x0b},
+	{0x484b, 0x47},
+	{0x484f, 0x00},
+	{0x4850, 0x42},
+	{0x4853, 0x8a},
+	{0x4855, 0x1c},
+	{0x4887, 0x51},
+	{0x4d15, 0x7d},
+	{0x4d30, 0x0a},
+	{0x4d31, 0x00},
+	{0x4d34, 0x7d},
+	{0x4d3c, 0x7d},
+	{0x4d5a, 0x1a},
+	{0x4f00, 0x00},
+	{0x4f01, 0x00},
+	{0x4f02, 0x00},
+	{0x4f03, 0x20},
+	{0x4f04, 0xe0},
+	{0x6a08, 0xcf},
+	{0x6a09, 0x01},
+	{0x6a0a, 0x40},
+	{0x6a24, 0x00},
+	{0x6a25, 0x00},
+	{0x5001, 0x75},
+	{0x5002, 0x7f},
+	{0x5003, 0x3e},
+	{0x5004, 0x3e},
+	{0x5005, 0x1e},
+	{0x5006, 0x1e},
+	{0x5007, 0x1e},
+	{0x500c, 0x00},
+	{0x502c, 0x00},
+	{0x502e, 0x00},
+	{0x502f, 0x00},
+	{0x504b, 0x00},
+	{0x5053, 0x00},
+	{0x505b, 0x00},
+	{0x5063, 0x00},
+	{0x5070, 0x00},
+	{0x5074, 0x04},
+	{0x507a, 0x9b},
+	{0x507b, 0x19},
+	{0x5204, 0x00},
+	{0x5404, 0x00},
+	{0x5314, 0x70},
+	{0x5315, 0xa6},
+	{0x5316, 0x73},
+	{0x5317, 0xff},
+	{0x5b80, 0xc0},
+	{0x5b93, 0x80},
+	{0x5b96, 0x80},
+	{0x5b97, 0x80},
+	{0x5b98, 0x60},
+	{0x5b99, 0x40},
+	{0x5b9a, 0x00},
+	{0x5b9b, 0x00},
+	{0x5b9c, 0x80},
+	{0x5b9d, 0x60},
+	{0x5b9e, 0x40},
+	{0x5b9f, 0x00},
+	{0x5ba0, 0x00},
+	{0x5ba1, 0x00},
+	{0x5ba2, 0x20},
+	{0x5ba3, 0x10},
+	{0x5ba4, 0x00},
+	{0x5ba5, 0x00},
+	{0x5ba6, 0x00},
+	{0x5ba7, 0x00},
+	{0x5bbe, 0x0a},
+	{0x5c00, 0xc0},
+	{0x5c13, 0x80},
+	{0x5c16, 0x80},
+	{0x5c17, 0x80},
+	{0x5c18, 0x60},
+	{0x5c19, 0x40},
+	{0x5c1a, 0x00},
+	{0x5c1b, 0x00},
+	{0x5c1c, 0x80},
+	{0x5c1d, 0x60},
+	{0x5c1e, 0x40},
+	{0x5c1f, 0x00},
+	{0x5c20, 0x00},
+	{0x5c21, 0x00},
+	{0x5c22, 0x20},
+	{0x5c23, 0x10},
+	{0x5c24, 0x00},
+	{0x5c25, 0x00},
+	{0x5c26, 0x00},
+	{0x5c27, 0x00},
+	{0x5c3e, 0x0a},
+	{0x5c80, 0xc0},
+	{0x5c93, 0x80},
+	{0x5c96, 0x80},
+	{0x5c97, 0x80},
+	{0x5c98, 0x60},
+	{0x5c99, 0x40},
+	{0x5c9a, 0x00},
+	{0x5c9b, 0x00},
+	{0x5c9c, 0x80},
+	{0x5c9d, 0x60},
+	{0x5c9e, 0x40},
+	{0x5c9f, 0x00},
+	{0x5ca0, 0x00},
+	{0x5ca1, 0x00},
+	{0x5ca2, 0x20},
+	{0x5ca3, 0x10},
+	{0x5ca4, 0x00},
+	{0x5ca5, 0x00},
+	{0x5ca6, 0x00},
+	{0x5ca7, 0x00},
+	{0x5cbe, 0x0a},
+	{0x6006, 0x00},
+	{0x6007, 0x04},
+	{0x6008, 0x06},
+	{0x6009, 0x01},
+	{0x600a, 0x00},
+	{0x600b, 0x08},
+	{0x600c, 0x07},
+	{0x600d, 0x87},
+	{0x6016, 0x00},
+	{0x6026, 0x00},
+	{0x6027, 0x04},
+	{0x6028, 0x06},
+	{0x6029, 0x01},
+	{0x602a, 0x00},
+	{0x602b, 0x08},
+	{0x602c, 0x07},
+	{0x602d, 0x87},
+	{0x6046, 0x00},
+	{0x6047, 0x04},
+	{0x6048, 0x06},
+	{0x6049, 0x01},
+	{0x604a, 0x00},
+	{0x604b, 0x08},
+	{0x604c, 0x07},
+	{0x604d, 0x87},
+	{0x6066, 0x00},
+	{0x6067, 0x04},
+	{0x6068, 0x06},
+	{0x6069, 0x01},
+	{0x606a, 0x00},
+	{0x606b, 0x08},
+	{0x606c, 0x07},
+	{0x606d, 0x87},
+	{0x6086, 0x00},
+	{0x6087, 0x04},
+	{0x6088, 0x06},
+	{0x6089, 0x01},
+	{0x608a, 0x00},
+	{0x608b, 0x08},
+	{0x608c, 0x07},
+	{0x608d, 0x87},
+	{0x5e00, 0x00},
+	{0x5e01, 0x09},
+	{0x5e02, 0x09},
+	{0x5e03, 0x0a},
+	{0x5e04, 0x0a},
+	{0x5e05, 0x0a},
+	{0x5e06, 0x0b},
+	{0x5e07, 0x0b},
+	{0x5e08, 0x0c},
+	{0x5e09, 0x0c},
+	{0x5e0a, 0x0d},
+	{0x5e0b, 0x0d},
+	{0x5e0c, 0x0e},
+	{0x5e0d, 0x0e},
+	{0x5e0e, 0x0f},
+	{0x5e0f, 0x0f},
+	{0x5e10, 0x10},
+	{0x5e11, 0x10},
+	{0x5e12, 0x11},
+	{0x5e13, 0x11},
+	{0x5e14, 0x12},
+	{0x5e15, 0x12},
+	{0x5e16, 0x12},
+	{0x5e17, 0x12},
+	{0x5e18, 0x13},
+	{0x5e19, 0x13},
+	{0x5e1a, 0x13},
+	{0x5e1b, 0x14},
+	{0x5e1c, 0x14},
+	{0x5e1d, 0x14},
+	{0x5e1e, 0x15},
+	{0x5e1f, 0x15},
+	{0x5e20, 0x15},
+	{0x5e21, 0x16},
+	{0x5e22, 0x00},
+	{0x5e23, 0x02},
+	{0x5e26, 0x00},
+	{0x5e27, 0xff},
+	{0x5e29, 0x01},
+	{0x5e2a, 0x00},
+	{0x5e2c, 0x01},
+	{0x5e2d, 0x00},
+	{0x5e2f, 0x01},
+	{0x5e30, 0x00},
+	{0x5e32, 0x00},
+	{0x5e33, 0x80},
+	{0x5e34, 0x00},
+	{0x5e35, 0x00},
+	{0x5e36, 0x80},
+	{0x5e37, 0x00},
+	{0x5e38, 0x00},
+	{0x5e39, 0x80},
+	{0x5e3a, 0x00},
+	{0x5e3b, 0x00},
+	{0x5e3c, 0x80},
+	{0x5e3d, 0x00},
+	{0x5e3e, 0x00},
+	{0x5e3f, 0x80},
+	{0x5e40, 0x00},
+	{0x5e41, 0x00},
+	{0x5e42, 0x80},
+	{0x5e43, 0x00},
+	{0x5e44, 0x00},
+	{0x5e45, 0x80},
+	{0x5e46, 0x00},
+	{0x5e47, 0x00},
+	{0x5e48, 0x80},
+	{0x5e49, 0x00},
+	{0x5e4a, 0x00},
+	{0x5e4b, 0x80},
+	{0x5e4c, 0x00},
+	{0x5e4d, 0x00},
+	{0x5e4e, 0x80},
+	{0x5e50, 0x00},
+	{0x5e51, 0x80},
+	{0x5e53, 0x00},
+	{0x5e54, 0x80},
+	{0x5e56, 0x00},
+	{0x5e57, 0x40},
+	{0x5e59, 0x00},
+	{0x5e5a, 0x40},
+	{0x5e5c, 0x00},
+	{0x5e5d, 0x40},
+	{0x5e5f, 0x00},
+	{0x5e60, 0x40},
+	{0x5e62, 0x00},
+	{0x5e63, 0x40},
+	{0x5e65, 0x00},
+	{0x5e66, 0x40},
+	{0x5e68, 0x00},
+	{0x5e69, 0x40},
+	{0x5e6b, 0x00},
+	{0x5e6c, 0x40},
+	{0x5e6e, 0x00},
+	{0x5e6f, 0x40},
+	{0x5e71, 0x00},
+	{0x5e72, 0x40},
+	{0x5e74, 0x00},
+	{0x5e75, 0x40},
+	{0x5e77, 0x00},
+	{0x5e78, 0x40},
+	{0x5e7a, 0x00},
+	{0x5e7b, 0x40},
+	{0x5e7d, 0x00},
+	{0x5e7e, 0x40},
+	{0x5e80, 0x00},
+	{0x5e81, 0x40},
+	{0x5e83, 0x00},
+	{0x5e84, 0x40},
+	{0x5f00, 0x02},
+	{0x5f01, 0x08},
+	{0x5f02, 0x09},
+	{0x5f03, 0x0a},
+	{0x5f04, 0x0b},
+	{0x5f05, 0x0c},
+	{0x5f06, 0x0c},
+	{0x5f07, 0x0c},
+	{0x5f08, 0x0c},
+	{0x5f09, 0x0c},
+	{0x5f0a, 0x0d},
+	{0x5f0b, 0x0d},
+	{0x5f0c, 0x0d},
+	{0x5f0d, 0x0d},
+	{0x5f0e, 0x0d},
+	{0x5f0f, 0x0e},
+	{0x5f10, 0x0e},
+	{0x5f11, 0x0e},
+	{0x5f12, 0x0e},
+	{0x5f13, 0x0f},
+	{0x5f14, 0x0f},
+	{0x5f15, 0x10},
+	{0x5f16, 0x11},
+	{0x5f17, 0x11},
+	{0x5f18, 0x12},
+	{0x5f19, 0x12},
+	{0x5f1a, 0x13},
+	{0x5f1b, 0x13},
+	{0x5f1c, 0x14},
+	{0x5f1d, 0x14},
+	{0x5f1e, 0x16},
+	{0x5f1f, 0x16},
+	{0x5f20, 0x16},
+	{0x5f21, 0x08},
+	{0x5f22, 0x00},
+	{0x5f23, 0x01},
+	{0x5f26, 0x02},
+	{0x5f27, 0x00},
+	{0x5f29, 0x02},
+	{0x5f2a, 0x00},
+	{0x5f2c, 0x02},
+	{0x5f2d, 0x00},
+	{0x5f2f, 0x02},
+	{0x5f30, 0x00},
+	{0x5f32, 0x02},
+	{0x5f33, 0x00},
+	{0x5f34, 0x00},
+	{0x5f35, 0x02},
+	{0x5f36, 0x00},
+	{0x5f37, 0x00},
+	{0x5f38, 0x02},
+	{0x5f39, 0x00},
+	{0x5f3a, 0x00},
+	{0x5f3b, 0x02},
+	{0x5f3c, 0x00},
+	{0x5f3d, 0x00},
+	{0x5f3e, 0x02},
+	{0x5f3f, 0x00},
+	{0x5f40, 0x00},
+	{0x5f41, 0x02},
+	{0x5f42, 0x00},
+	{0x5f43, 0x00},
+	{0x5f44, 0x02},
+	{0x5f45, 0x00},
+	{0x5f46, 0x00},
+	{0x5f47, 0x04},
+	{0x5f48, 0x00},
+	{0x5f49, 0x00},
+	{0x5f4a, 0x04},
+	{0x5f4b, 0x00},
+	{0x5f4c, 0x00},
+	{0x5f4d, 0x04},
+	{0x5f4e, 0x00},
+	{0x5f50, 0x04},
+	{0x5f51, 0x00},
+	{0x5f53, 0x04},
+	{0x5f54, 0x00},
+	{0x5f56, 0x04},
+	{0x5f57, 0x00},
+	{0x5f59, 0x04},
+	{0x5f5a, 0x00},
+	{0x5f5c, 0x04},
+	{0x5f5d, 0x00},
+	{0x5f5f, 0x08},
+	{0x5f60, 0x00},
+	{0x5f62, 0x08},
+	{0x5f63, 0x00},
+	{0x5f65, 0x08},
+	{0x5f66, 0x00},
+	{0x5f68, 0x08},
+	{0x5f69, 0x00},
+	{0x5f6b, 0x08},
+	{0x5f6c, 0x00},
+	{0x5f6e, 0x10},
+	{0x5f6f, 0x00},
+	{0x5f71, 0x10},
+	{0x5f72, 0x00},
+	{0x5f74, 0x10},
+	{0x5f75, 0x00},
+	{0x5f77, 0x10},
+	{0x5f78, 0x00},
+	{0x5f7a, 0x20},
+	{0x5f7b, 0x00},
+	{0x5f7d, 0x20},
+	{0x5f7e, 0x00},
+	{0x5f80, 0x20},
+	{0x5f81, 0x00},
+	{0x5f83, 0x00},
+	{0x5f84, 0xff},
+	{0x5240, 0x0f},
+	{0x5241, 0x00},
+	{0x5242, 0x00},
+	{0x5243, 0x00},
+	{0x5244, 0x00},
+	{0x5245, 0x00},
+	{0x5246, 0x00},
+	{0x5247, 0x00},
+	{0x5248, 0x00},
+	{0x5249, 0x00},
+	{0x5440, 0x0f},
+	{0x5441, 0x00},
+	{0x5442, 0x00},
+	{0x5443, 0x00},
+	{0x5444, 0x00},
+	{0x5445, 0x00},
+	{0x5446, 0x00},
+	{0x5447, 0x00},
+	{0x5448, 0x00},
+	{0x5449, 0x00},
+	{0x5640, 0x0f},
+	{0x5641, 0x00},
+	{0x5642, 0x00},
+	{0x5643, 0x00},
+	{0x5644, 0x00},
+	{0x5645, 0x00},
+	{0x5646, 0x00},
+	{0x5647, 0x00},
+	{0x5648, 0x00},
+	{0x5649, 0x00},
+	{0x5840, 0x0f},
+	{0x5841, 0x00},
+	{0x5842, 0x00},
+	{0x5843, 0x00},
+	{0x5844, 0x00},
+	{0x5845, 0x00},
+	{0x5846, 0x00},
+	{0x5847, 0x00},
+	{0x5848, 0x00},
+	{0x5849, 0x00},
+	{0x4001, 0x2b},
+	{0x400e, 0x01},
+	{0x400f, 0xff},
+	{0x4018, 0x12},
+	{0x4022, 0x40},
+	{0x4023, 0x20},
+	{0x4026, 0x00},
+	{0x4027, 0x40},
+	{0x4028, 0x00},
+	{0x4029, 0x40},
+	{0x402a, 0x00},
+	{0x402b, 0x40},
+	{0x402c, 0x00},
+	{0x402d, 0x40},
+	{0x407e, 0xcc},
+	{0x407f, 0x18},
+	{0x4082, 0x00},
+	{0x4083, 0xc8},
+	{0x4084, 0x00},
+	{0x4085, 0x98},
+	{0x4086, 0x00},
+	{0x4087, 0x98},
+	{0x4640, 0x40},
+	{0x4641, 0x11},
+	{0x4642, 0x0e},
+	{0x4643, 0xee},
+	{0x4646, 0x0f},
+	{0x4648, 0x00},
+	{0x4649, 0x03},
+	{0x4702, 0x00},
+	{0x5d0d, 0x08},
+	{0x5d0e, 0x08},
+	{0x5d0f, 0x08},
+	{0x5d11, 0x10},
+	{0x5d12, 0x10},
+	{0x5d13, 0x0f},
+	{0x5d15, 0x04},
+	{0x5d16, 0x04},
+	{0x5d17, 0x02},
+	{0x5d1f, 0x81},
+	{0x6120, 0x75},
+	{0x6121, 0x75},
+	{0x6122, 0x75},
+	{0x6123, 0x75},
+	{0x6124, 0x75},
+	{0x6125, 0x75},
+	{0x6126, 0x75},
+	{0x6127, 0x75},
+	{0x6128, 0x75},
+	{0x6129, 0x75},
+	{0x612a, 0x75},
+	{0x612b, 0x75},
+	{0x612c, 0x75},
+	{0x612d, 0x75},
+	{0x612e, 0x75},
+	{0x612f, 0x75},
+	{0x6130, 0x75},
+	{0x6131, 0x75},
+	{0x6132, 0x75},
+	{0x6133, 0x75},
+	{0x6134, 0x75},
+	{0x6135, 0x75},
+	{0x6136, 0x75},
+	{0x6137, 0x75},
+	{0x6138, 0x75},
+	{0x6139, 0x75},
+	{0x613a, 0x75},
+	{0x613b, 0x75},
+	{0x613c, 0x75},
+	{0x613d, 0x75},
+	{0x613e, 0x75},
+	{0x613f, 0x75},
+	{0x6140, 0x75},
+	{0x6141, 0x75},
+	{0x6142, 0x75},
+	{0x6143, 0x75},
+	{0x4f04, 0xf8},
+	{0x4d09, 0xdf},
+	{0x5019, 0x00},
+	{0x501a, 0xff},
+	{0x501b, 0xff},
+	{0x501d, 0x00},
+	{0x501e, 0x23},
+	{0x501f, 0x8e},
+	{0x5021, 0x00},
+	{0x5022, 0x00},
+	{0x5023, 0x99},
+	{0x5025, 0x00},
+	{0x5026, 0x23},
+	{0x5027, 0x8e},
+	{0x5003, 0x3a},
+	{0x5b80, 0x08},
+	{0x5c00, 0x08},
+	{0x5c80, 0x00},
+	{0x5bbe, 0x12},
+	{0x5c3e, 0x12},
+	{0x5cbe, 0x12},
+	{0x5b8a, 0x80},
+	{0x5b8b, 0x80},
+	{0x5b8c, 0x80},
+	{0x5b8d, 0x80},
+	{0x5b8e, 0x80},
+	{0x5b8f, 0x40},
+	{0x5b90, 0x80},
+	{0x5b91, 0x80},
+	{0x5b92, 0x80},
+	{0x5b93, 0x60},
+	{0x5b94, 0x00},
+	{0x5b95, 0x00},
+	{0x5b96, 0x40},
+	{0x5b97, 0x80},
+	{0x5b98, 0x10},
+	{0x5b99, 0x00},
+	{0x5b9a, 0x00},
+	{0x5b9b, 0x00},
+	{0x5b9c, 0x00},
+	{0x5b9d, 0x00},
+	{0x5b9e, 0x00},
+	{0x5b9f, 0x00},
+	{0x5ba0, 0x00},
+	{0x5ba1, 0x00},
+	{0x5ba2, 0x00},
+	{0x5ba3, 0x00},
+	{0x5ba4, 0x00},
+	{0x5ba5, 0x00},
+	{0x5ba6, 0x00},
+	{0x5ba7, 0x00},
+	{0x5ba8, 0x00},
+	{0x5ba9, 0xc0},
+	{0x5baa, 0x01},
+	{0x5bab, 0x40},
+	{0x5bac, 0x02},
+	{0x5bad, 0x40},
+	{0x5bae, 0x00},
+	{0x5baf, 0x50},
+	{0x5bb0, 0x00},
+	{0x5bb1, 0x60},
+	{0x5bb2, 0x00},
+	{0x5bb3, 0xc0},
+	{0x5c0a, 0x80},
+	{0x5c0b, 0x80},
+	{0x5c0c, 0x80},
+	{0x5c0d, 0x80},
+	{0x5c0e, 0x60},
+	{0x5c0f, 0x80},
+	{0x5c10, 0x80},
+	{0x5c11, 0x80},
+	{0x5c12, 0x60},
+	{0x5c13, 0x20},
+	{0x5c14, 0x80},
+	{0x5c15, 0x80},
+	{0x5c16, 0x80},
+	{0x5c17, 0x20},
+	{0x5c18, 0x00},
+	{0x5c19, 0x80},
+	{0x5c1a, 0x40},
+	{0x5c1b, 0x20},
+	{0x5c1c, 0x00},
+	{0x5c1d, 0x00},
+	{0x5c1e, 0x80},
+	{0x5c1f, 0x00},
+	{0x5c20, 0x00},
+	{0x5c21, 0x00},
+	{0x5c22, 0x00},
+	{0x5c23, 0x00},
+	{0x5c24, 0x00},
+	{0x5c25, 0x00},
+	{0x5c26, 0x00},
+	{0x5c27, 0x00},
+	{0x5c28, 0x02},
+	{0x5c29, 0x00},
+	{0x5c2a, 0x02},
+	{0x5c2b, 0x76},
+	{0x5c2c, 0x03},
+	{0x5c2d, 0x08},
+	{0x5c2e, 0x00},
+	{0x5c2f, 0x80},
+	{0x5c30, 0x01},
+	{0x5c31, 0x00},
+	{0x5c32, 0x02},
+	{0x5c33, 0x00},
+	{0x5c8a, 0x80},
+	{0x5c8b, 0x80},
+	{0x5c8c, 0x80},
+	{0x5c8d, 0x80},
+	{0x5c8e, 0x80},
+	{0x5c8f, 0x80},
+	{0x5c90, 0x80},
+	{0x5c91, 0x80},
+	{0x5c92, 0x80},
+	{0x5c93, 0x60},
+	{0x5c94, 0x80},
+	{0x5c95, 0x80},
+	{0x5c96, 0x80},
+	{0x5c97, 0x60},
+	{0x5c98, 0x40},
+	{0x5c99, 0x80},
+	{0x5c9a, 0x80},
+	{0x5c9b, 0x80},
+	{0x5c9c, 0x40},
+	{0x5c9d, 0x20},
+	{0x5c9e, 0x80},
+	{0x5c9f, 0x80},
+	{0x5ca0, 0x80},
+	{0x5ca1, 0x20},
+	{0x5ca2, 0x00},
+	{0x5ca3, 0x80},
+	{0x5ca4, 0x80},
+	{0x5ca5, 0x80},
+	{0x5ca6, 0x00},
+	{0x5ca7, 0x00},
+	{0x5ca8, 0x01},
+	{0x5ca9, 0x00},
+	{0x5caa, 0x02},
+	{0x5cab, 0x00},
+	{0x5cac, 0x03},
+	{0x5cad, 0x08},
+	{0x5cae, 0x01},
+	{0x5caf, 0x00},
+	{0x5cb0, 0x02},
+	{0x5cb1, 0x00},
+	{0x5cb2, 0x03},
+	{0x5cb3, 0x08},
+	{0x5be7, 0x80},
+	{0x5bc9, 0x80},
+	{0x5bca, 0x80},
+	{0x5bcb, 0x80},
+	{0x5bcc, 0x80},
+	{0x5bcd, 0x80},
+	{0x5bce, 0x80},
+	{0x5bcf, 0x80},
+	{0x5bd0, 0x80},
+	{0x5bd1, 0x80},
+	{0x5bd2, 0x20},
+	{0x5bd3, 0x80},
+	{0x5bd4, 0x40},
+	{0x5bd5, 0x20},
+	{0x5bd6, 0x00},
+	{0x5bd7, 0x00},
+	{0x5bd8, 0x00},
+	{0x5bd9, 0x00},
+	{0x5bda, 0x00},
+	{0x5bdb, 0x00},
+	{0x5bdc, 0x00},
+	{0x5bdd, 0x00},
+	{0x5bde, 0x00},
+	{0x5bdf, 0x00},
+	{0x5be0, 0x00},
+	{0x5be1, 0x00},
+	{0x5be2, 0x00},
+	{0x5be3, 0x00},
+	{0x5be4, 0x00},
+	{0x5be5, 0x00},
+	{0x5be6, 0x00},
+	{0x5c49, 0x80},
+	{0x5c4a, 0x80},
+	{0x5c4b, 0x80},
+	{0x5c4c, 0x80},
+	{0x5c4d, 0x40},
+	{0x5c4e, 0x80},
+	{0x5c4f, 0x80},
+	{0x5c50, 0x80},
+	{0x5c51, 0x60},
+	{0x5c52, 0x20},
+	{0x5c53, 0x80},
+	{0x5c54, 0x80},
+	{0x5c55, 0x80},
+	{0x5c56, 0x20},
+	{0x5c57, 0x00},
+	{0x5c58, 0x80},
+	{0x5c59, 0x40},
+	{0x5c5a, 0x20},
+	{0x5c5b, 0x00},
+	{0x5c5c, 0x00},
+	{0x5c5d, 0x80},
+	{0x5c5e, 0x00},
+	{0x5c5f, 0x00},
+	{0x5c60, 0x00},
+	{0x5c61, 0x00},
+	{0x5c62, 0x00},
+	{0x5c63, 0x00},
+	{0x5c64, 0x00},
+	{0x5c65, 0x00},
+	{0x5c66, 0x00},
+	{0x5cc9, 0x80},
+	{0x5cca, 0x80},
+	{0x5ccb, 0x80},
+	{0x5ccc, 0x80},
+	{0x5ccd, 0x80},
+	{0x5cce, 0x80},
+	{0x5ccf, 0x80},
+	{0x5cd0, 0x80},
+	{0x5cd1, 0x80},
+	{0x5cd2, 0x60},
+	{0x5cd3, 0x80},
+	{0x5cd4, 0x80},
+	{0x5cd5, 0x80},
+	{0x5cd6, 0x60},
+	{0x5cd7, 0x40},
+	{0x5cd8, 0x80},
+	{0x5cd9, 0x80},
+	{0x5cda, 0x80},
+	{0x5cdb, 0x40},
+	{0x5cdc, 0x20},
+	{0x5cdd, 0x80},
+	{0x5cde, 0x80},
+	{0x5cdf, 0x80},
+	{0x5ce0, 0x20},
+	{0x5ce1, 0x00},
+	{0x5ce2, 0x80},
+	{0x5ce3, 0x80},
+	{0x5ce4, 0x80},
+	{0x5ce5, 0x00},
+	{0x5ce6, 0x00},
+	{0x5b84, 0x02},
+	{0x5b85, 0xcc},
+	{0x5bb4, 0x05},
+	{0x5bb5, 0xc6},
+	{0x5c04, 0x02},
+	{0x5c05, 0xcc},
+	{0x5c34, 0x05},
+	{0x5c35, 0x33},
+	{0x5c84, 0x02},
+	{0x5c85, 0xcc},
+	{0x5cb4, 0x05},
+	{0x5cb5, 0x33},
+	{0x5bbf, 0x00},
+	{0x5bc0, 0x04},
+	{0x5bc1, 0x06},
+	{0x5bc2, 0xff},
+	{0x5bc3, 0x00},
+	{0x5bc4, 0x04},
+	{0x5bc5, 0x02},
+	{0x5bc6, 0xb8},
+	{0x5c3f, 0x00},
+	{0x5c40, 0x04},
+	{0x5c41, 0x07},
+	{0x5c42, 0xff},
+	{0x5c43, 0x00},
+	{0x5c44, 0x04},
+	{0x5c45, 0x03},
+	{0x5c46, 0xb8},
+	{0x5cbf, 0x00},
+	{0x5cc0, 0x20},
+	{0x5cc1, 0x07},
+	{0x5cc2, 0xff},
+	{0x5cc3, 0x00},
+	{0x5cc4, 0x20},
+	{0x5cc5, 0x03},
+	{0x5cc6, 0x00},
+	{0x5b86, 0x05},
+	{0x5c06, 0x05},
+	{0x5c86, 0x05},
+	{0x5bb8, 0x01},
+	{0x5bb9, 0x01},
+	{0x5c38, 0x01},
+	{0x5c39, 0x01},
+	{0x5cb8, 0x01},
+	{0x5cb9, 0x01},
+	{0x5bc7, 0x00},
+	{0x5bc8, 0x80},
+	{0x5c47, 0x00},
+	{0x5c48, 0x80},
+	{0x5cc7, 0x00},
+	{0x5cc8, 0x80},
+	{0x5bba, 0x01},
+	{0x5bbb, 0x00},
+	{0x5c3a, 0x01},
+	{0x5c3b, 0x00},
+	{0x5cba, 0x01},
+	{0x5cbb, 0x00},
+	{0x5d74, 0x01},
+	{0x5d75, 0x00},
+	{0x5d1f, 0x81},
+	{0x5d11, 0x00},
+	{0x5d12, 0x10},
+	{0x5d13, 0x10},
+	{0x5d15, 0x05},
+	{0x5d16, 0x05},
+	{0x5d17, 0x05},
+	{0x5d08, 0x03},
+	{0x5d09, 0x6b},
+	{0x5d0a, 0x03},
+	{0x5d0b, 0x6b},
+	{0x5d18, 0x03},
+	{0x5d19, 0x6b},
+	{0x5b40, 0x01},
+	{0x5b41, 0x00},
+	{0x5b42, 0x00},
+	{0x5b43, 0x00},
+	{0x5b44, 0x00},
+	{0x5b45, 0x00},
+	{0x5b46, 0x00},
+	{0x5b47, 0x00},
+	{0x5b48, 0x01},
+	{0x5b49, 0x00},
+	{0x5b4a, 0x00},
+	{0x5b4b, 0x00},
+	{0x5b4c, 0x00},
+	{0x5b4d, 0x00},
+	{0x5b4e, 0x00},
+	{0x5b4f, 0x00},
+	{0x5b50, 0x01},
+	{0x5b51, 0x00},
+	{0x5b52, 0x01},
+	{0x5b53, 0x00},
+	{0x5b54, 0x00},
+	{0x5b55, 0x00},
+	{0x5b56, 0x00},
+	{0x5b57, 0x00},
+	{0x5b58, 0x00},
+	{0x5b59, 0x00},
+	{0x5b5a, 0x01},
+	{0x5b5b, 0x00},
+	{0x5b5c, 0x00},
+	{0x5b5d, 0x00},
+	{0x5b5e, 0x00},
+	{0x5b5f, 0x00},
+	{0x5b60, 0x00},
+	{0x5b61, 0x00},
+	{0x5b62, 0x01},
+	{0x5b63, 0x00},
+	{0x5b64, 0x01},
+	{0x5b65, 0x00},
+	{0x5b66, 0x00},
+	{0x5b67, 0x00},
+	{0x5b68, 0x00},
+	{0x5b69, 0x00},
+	{0x5b6a, 0x00},
+	{0x5b6b, 0x00},
+	{0x5b6c, 0x01},
+	{0x5b6d, 0x00},
+	{0x5b6e, 0x00},
+	{0x5b6f, 0x00},
+	{0x5b70, 0x00},
+	{0x5b71, 0x00},
+	{0x5b72, 0x00},
+	{0x5b73, 0x00},
+	{0x5b74, 0x01},
+	{0x5b75, 0x00},
+	{0x5b78, 0x00},
+	{0x5b79, 0x56},
+	{0x5b7a, 0x00},
+	{0x5b7b, 0xc3},
+	{0x5b7c, 0x01},
+	{0x5b7d, 0x3f},
+	{0x5b7e, 0x01},
+	{0x5280, 0x04},
+	{0x5281, 0x00},
+	{0x5282, 0x04},
+	{0x5283, 0x00},
+	{0x5284, 0x04},
+	{0x5285, 0x00},
+	{0x5286, 0x04},
+	{0x5287, 0x00},
+	{0x5480, 0x04},
+	{0x5481, 0x00},
+	{0x5482, 0x04},
+	{0x5483, 0x00},
+	{0x5484, 0x04},
+	{0x5485, 0x00},
+	{0x5486, 0x04},
+	{0x5487, 0x00},
+	{0x5680, 0x04},
+	{0x5681, 0x00},
+	{0x5682, 0x04},
+	{0x5683, 0x00},
+	{0x5684, 0x04},
+	{0x5685, 0x00},
+	{0x5686, 0x04},
+	{0x5687, 0x00},
+	{0x5880, 0x04},
+	{0x5881, 0x00},
+	{0x5882, 0x04},
+	{0x5883, 0x00},
+	{0x5884, 0x04},
+	{0x5885, 0x00},
+	{0x5886, 0x04},
+	{0x5887, 0x00},
+	{0x52c6, 0x00},
+	{0x52c7, 0x12},
+	{0x52c8, 0x04},
+	{0x52c9, 0x02},
+	{0x52ca, 0x01},
+	{0x52cb, 0x01},
+	{0x52cc, 0x04},
+	{0x52cd, 0x02},
+	{0x52ce, 0x01},
+	{0x52cf, 0x01},
+	{0x52d0, 0x03},
+	{0x52d1, 0x08},
+	{0x52d2, 0x0c},
+	{0x54c6, 0x00},
+	{0x54c7, 0x12},
+	{0x54c8, 0x04},
+	{0x54c9, 0x02},
+	{0x54ca, 0x01},
+	{0x54cb, 0x01},
+	{0x54cc, 0x04},
+	{0x54cd, 0x02},
+	{0x54ce, 0x01},
+	{0x54cf, 0x01},
+	{0x54d0, 0x03},
+	{0x54d1, 0x08},
+	{0x54d2, 0x0c},
+	{0x56c6, 0x00},
+	{0x56c7, 0x12},
+	{0x56c8, 0x04},
+	{0x56c9, 0x02},
+	{0x56ca, 0x01},
+	{0x56cb, 0x01},
+	{0x56cc, 0x04},
+	{0x56cd, 0x02},
+	{0x56ce, 0x01},
+	{0x56cf, 0x01},
+	{0x56d0, 0x03},
+	{0x56d1, 0x08},
+	{0x56d2, 0x0c},
+	{0x58c6, 0x00},
+	{0x58c7, 0x12},
+	{0x58c8, 0x04},
+	{0x58c9, 0x02},
+	{0x58ca, 0x01},
+	{0x58cb, 0x01},
+	{0x58cc, 0x04},
+	{0x58cd, 0x02},
+	{0x58ce, 0x01},
+	{0x58cf, 0x01},
+	{0x58d0, 0x03},
+	{0x58d1, 0x08},
+	{0x58d2, 0x0c},
+	{0x5004, 0x1e},
+	{0x610a, 0x07},
+	{0x610b, 0x80},
+	{0x610c, 0x06},
+	{0x610d, 0x00},
+	{0x6102, 0x3f},
+	{0x6120, 0x75},
+	{0x6121, 0x75},
+	{0x6122, 0x75},
+	{0x6123, 0x75},
+	{0x6124, 0x75},
+	{0x6125, 0x75},
+	{0x6126, 0x75},
+	{0x6127, 0x75},
+	{0x6128, 0x75},
+	{0x6129, 0x75},
+	{0x612a, 0x75},
+	{0x612b, 0x75},
+	{0x612c, 0x75},
+	{0x612d, 0x75},
+	{0x612e, 0x75},
+	{0x612f, 0x75},
+	{0x6130, 0x75},
+	{0x6131, 0x75},
+	{0x6132, 0x75},
+	{0x6133, 0x75},
+	{0x6134, 0x75},
+	{0x6135, 0x75},
+	{0x6136, 0x75},
+	{0x6137, 0x75},
+	{0x6138, 0x75},
+	{0x6139, 0x75},
+	{0x613a, 0x75},
+	{0x613b, 0x75},
+	{0x613c, 0x75},
+	{0x613d, 0x75},
+	{0x613e, 0x75},
+	{0x613f, 0x75},
+	{0x6140, 0x75},
+	{0x6141, 0x75},
+	{0x6142, 0x75},
+	{0x6143, 0x75},
+	{0x6144, 0x75},
+	{0x6145, 0x75},
+	{0x6146, 0x75},
+	{0x6147, 0x75},
+	{0x6148, 0x75},
+	{0x6149, 0x75},
+	{0x614a, 0x75},
+	{0x614b, 0x75},
+	{0x614c, 0x75},
+	{0x614d, 0x75},
+	{0x614e, 0x75},
+	{0x614f, 0x75},
+	{0x6150, 0x75},
+	{0x6151, 0x75},
+	{0x6152, 0x75},
+	{0x6153, 0x75},
+	{0x6154, 0x75},
+	{0x6155, 0x75},
+	{0x6156, 0x75},
+	{0x6157, 0x75},
+	{0x6158, 0x75},
+	{0x6159, 0x75},
+	{0x615a, 0x75},
+	{0x615b, 0x75},
+	{0x615c, 0x75},
+	{0x615d, 0x75},
+	{0x615e, 0x75},
+	{0x615f, 0x75},
+	{0x6160, 0x75},
+	{0x6161, 0x75},
+	{0x6162, 0x75},
+	{0x6163, 0x75},
+	{0x6164, 0x75},
+	{0x6165, 0x75},
+	{0x6166, 0x75},
+	{0x6167, 0x75},
+	{0x6168, 0x75},
+	{0x6169, 0x75},
+	{0x616a, 0x75},
+	{0x616b, 0x75},
+	{0x616c, 0x75},
+	{0x616d, 0x75},
+	{0x616e, 0x75},
+	{0x616f, 0x75},
+	{0x6170, 0x75},
+	{0x6171, 0x75},
+	{0x6172, 0x75},
+	{0x6173, 0x75},
+	{0x6174, 0x75},
+	{0x6175, 0x75},
+	{0x6176, 0x75},
+	{0x6177, 0x75},
+	{0x6178, 0x75},
+	{0x6179, 0x75},
+	{0x617a, 0x75},
+	{0x617b, 0x75},
+	{0x617c, 0x75},
+	{0x617d, 0x75},
+	{0x617e, 0x75},
+	{0x617f, 0x75},
+	{0x6180, 0x75},
+	{0x6181, 0x75},
+	{0x6182, 0x75},
+	{0x6183, 0x75},
+	{0x6184, 0x75},
+	{0x6185, 0x75},
+	{0x6186, 0x75},
+	{0x6187, 0x75},
+	{0x6188, 0x75},
+	{0x6189, 0x75},
+	{0x618a, 0x75},
+	{0x618b, 0x75},
+	{0x618c, 0x75},
+	{0x618d, 0x75},
+	{0x618e, 0x75},
+	{0x618f, 0x75},
+	{0x6190, 0x75},
+	{0x6191, 0x75},
+	{0x6192, 0x75},
+	{0x6193, 0x75},
+	{0x6194, 0x75},
+	{0x6195, 0x75},
+	{0x6196, 0x75},
+	{0x6197, 0x75},
+	{0x6198, 0x75},
+	{0x6199, 0x75},
+	{0x619a, 0x75},
+	{0x619b, 0x75},
+	{0x619c, 0x75},
+	{0x619d, 0x75},
+	{0x619e, 0x75},
+	{0x619f, 0x75},
+	{0x61a0, 0x75},
+	{0x61a1, 0x75},
+	{0x61a2, 0x75},
+	{0x61a3, 0x75},
+	{0x61a4, 0x75},
+	{0x61a5, 0x75},
+	{0x61a6, 0x75},
+	{0x61a7, 0x75},
+	{0x61a8, 0x75},
+	{0x61a9, 0x75},
+	{0x61aa, 0x75},
+	{0x61ab, 0x75},
+	{0x61ac, 0x75},
+	{0x61ad, 0x75},
+	{0x61ae, 0x75},
+	{0x61af, 0x75},
+	{0x5d62, 0x07},
+	{0x5d40, 0x02},
+	{0x5d41, 0x01},
+	{0x5d63, 0x08},
+	{0x5d64, 0x01},
+	{0x5d65, 0xff},
+	{0x5d56, 0x00},
+	{0x5d57, 0x20},
+	{0x5d58, 0x00},
+	{0x5d59, 0x00},
+	{0x5d5a, 0x00},
+	{0x5d5b, 0x0c},
+	{0x5d5c, 0x02},
+	{0x5d5d, 0x40},
+	{0x5d5e, 0x02},
+	{0x5d5f, 0x40},
+	{0x5d60, 0x03},
+	{0x5d61, 0x40},
+	{0x5d4a, 0x02},
+	{0x5d4b, 0x40},
+	{0x5d4c, 0x02},
+	{0x5d4d, 0x40},
+	{0x5d4e, 0x02},
+	{0x5d4f, 0x40},
+	{0x5d50, 0x18},
+	{0x5d51, 0x80},
+	{0x5d52, 0x18},
+	{0x5d53, 0x80},
+	{0x5d54, 0x18},
+	{0x5d55, 0x80},
+	{0x5d46, 0x20},
+	{0x5d47, 0x00},
+	{0x5d48, 0x22},
+	{0x5d49, 0x00},
+	{0x5d42, 0x20},
+	{0x5d43, 0x00},
+	{0x5d44, 0x22},
+	{0x5d45, 0x00},
+	{0x5b40, 0x01},
+	{0x5b41, 0x0f},
+	{0x5b42, 0x0f},
+	{0x5b43, 0xf4},
+	{0x5b44, 0x0f},
+	{0x5b45, 0xfd},
+	{0x5b46, 0x0f},
+	{0x5b47, 0xf5},
+	{0x5b48, 0x01},
+	{0x5b49, 0x00},
+	{0x5b4a, 0x00},
+	{0x5b4b, 0x0b},
+	{0x5b4c, 0x0f},
+	{0x5b4d, 0xf9},
+	{0x5b4e, 0x0f},
+	{0x5b4f, 0xea},
+	{0x5b50, 0x01},
+	{0x5b51, 0x1d},
+	{0x5b52, 0x01},
+	{0x5b53, 0x0f},
+	{0x5b54, 0x0f},
+	{0x5b55, 0xf6},
+	{0x5b56, 0x0f},
+	{0x5b57, 0xfc},
+	{0x5b58, 0x0f},
+	{0x5b59, 0xf6},
+	{0x5b5a, 0x01},
+	{0x5b5b, 0x02},
+	{0x5b5c, 0x00},
+	{0x5b5d, 0x07},
+	{0x5b5e, 0x0f},
+	{0x5b5f, 0xf8},
+	{0x5b60, 0x0f},
+	{0x5b61, 0xd4},
+	{0x5b62, 0x01},
+	{0x5b63, 0x34},
+	{0x5b64, 0x01},
+	{0x5b65, 0x0c},
+	{0x5b66, 0x0f},
+	{0x5b67, 0xf3},
+	{0x5b68, 0x00},
+	{0x5b69, 0x01},
+	{0x5b6a, 0x0f},
+	{0x5b6b, 0xf3},
+	{0x5b6c, 0x01},
+	{0x5b6d, 0x00},
+	{0x5b6e, 0x00},
+	{0x5b6f, 0x0d},
+	{0x5b70, 0x0f},
+	{0x5b71, 0xe5},
+	{0x5b72, 0x0f},
+	{0x5b73, 0xcc},
+	{0x5b74, 0x01},
+	{0x5b75, 0x4e},
+	{0x5b78, 0x00},
+	{0x5b79, 0x56},
+	{0x5b7a, 0x00},
+	{0x5b7b, 0xc3},
+	{0x5b7c, 0x01},
+	{0x5b7d, 0x3f},
+	{0x5b7e, 0x01},
+	{0x5280, 0x05},
+	{0x5281, 0xa8},
+	{0x5282, 0x04},
+	{0x5283, 0x00},
+	{0x5284, 0x04},
+	{0x5285, 0x00},
+	{0x5286, 0x07},
+	{0x5287, 0x11},
+	{0x5480, 0x05},
+	{0x5481, 0xa8},
+	{0x5482, 0x04},
+	{0x5483, 0x00},
+	{0x5484, 0x04},
+	{0x5485, 0x00},
+	{0x5486, 0x07},
+	{0x5487, 0x11},
+	{0x5680, 0x06},
+	{0x5681, 0x53},
+	{0x5682, 0x04},
+	{0x5683, 0x00},
+	{0x5684, 0x04},
+	{0x5685, 0x00},
+	{0x5686, 0x06},
+	{0x5687, 0xcf},
+	{0x5880, 0x05},
+	{0x5881, 0xa8},
+	{0x5882, 0x04},
+	{0x5883, 0x00},
+	{0x5884, 0x04},
+	{0x5885, 0x00},
+	{0x5886, 0x07},
+	{0x5887, 0x11},
+	{0x4221, 0x03},
+	{0x0304, 0x00},
+	{0x0305, 0xe1},
+	{0x0307, 0x02},
+	{0x4837, 0x1b},
+	{0x0408, 0xe0},
+	{0x0409, 0x62},
+	{0x040a, 0xde},
+	{0x040b, 0x34},
+	{0x040c, 0x8f},
+	{0x040d, 0x9b},
+	{0x040e, 0x08},
+	{0x0324, 0x02},
+	{0x0325, 0x00},
+	{0x0400, 0xe0},
+	{0x0401, 0x80},
+	{0x0403, 0xde},
+	{0x0404, 0x34},
+	{0x0405, 0x54},
+	{0x0406, 0x30},
+	{0x0407, 0x08},
+	{0x380c, 0x04},
+	{0x380d, 0x4e},
+	{0x384c, 0x02},
+	{0x384d, 0x1a},
+	{0x388c, 0x02},
+	{0x388d, 0x1a},
+	{OX03F10_TABLE_WAIT, OX03F10_TABLE_WAIT_MS},
+	{0x3501, 0x01},
+	{0x3502, 0x44},
+	{0x3506, 0x30},
+	{0x3541, 0x01},
+	{0x3542, 0x44},
+	{0x3546, 0x10},
+	{0x35c1, 0x00},
+	{0x35c2, 0x02},
+	{0x35c6, 0x90},
+	{0x3586, 0x50},
+	{0x5003, 0x3a},
+	{0x4603, 0x13},
+	{0x4610, 0x00},
+	{0x4611, 0x30},
+	{0x4614, 0x00},
+	{0x4615, 0x30},
+	{0x4627, 0x66},
+	{0x4628, 0x5d},
+	{0x4629, 0xa8},
+	{0x462a, 0x55},
+	{0x507a, 0x5f},
+	{0x507b, 0x46},
+	{0x4f00, 0x3f},
+	{0x4f01, 0xff},
+	{0x4f02, 0xff},
+	{0x4f03, 0x2c},
+	{0x3820, 0x04},
+	{OX03F10_TABLE_WAIT, OX03F10_TABLE_WAIT_MS},
+	{OX03F10_TABLE_END, 0}
+};
+
+struct reg_8 ox03f10_start[] = {
+	{0x0100, 0x01},
+	{OX03F10_TABLE_END, 0}
+};
+
+struct reg_8 ox03f10_stop[] = {
+	{0x0100, 0x00},
+	{OX03F10_TABLE_END, 0}
+};
+
+#endif /* __LI_OX03F10__ */
-- 
1.8.3.1

